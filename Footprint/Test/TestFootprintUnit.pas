unit TestFootprintUnit;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, FootprintUnit, System.Classes, FootPrintUtilities;

type
  // Test methods for class TFootPrintGenerator

  TestTFootPrintGenerator = class(TTestCase)
  strict private
    FFootPrintGenerator: TFootPrintGenerator;
  private
    ListingfileName: string;
    procedure InitializeRealArray(var AnArray: TTwoDRealArray);
    procedure InitializeIntegerArray(var AnArray: TTwoDIntArray);
  public
    procedure SetUp; override;
    procedure TearDown; override;
    procedure SetupGenerateErrorIfWithdrawalsTooLarge;
    procedure SetupMissingListingFile;
    procedure SetupInvalidListingFile;
    procedure SetupInvalidListingFile2;
  published
    procedure TestLoadFromFile;
//    procedure TestSaveBinaryFile;
    procedure TestCapacityCalculation;
    procedure TestRetrieveWithdrawals;
    procedure TestInitialRedistribution;
    procedure TestInitialRedistributionSingleCell;
    procedure TestIdentifyInitialNeighborHoods;
    procedure TestIdentifyInitialNeighborHoodsWhenAppropriate;
    procedure TestGenerateErrorIfWithdrawalsTooLarge;
    procedure TestSetupNeighborCount;
    procedure TestComputeChangeForOneIteration;
    procedure TestRedistributeToPerimeter;
    procedure TestMissingListingFile;
    procedure TestInvalidListingFile;
    procedure TestInvalidListingFile2;
    procedure TestGenerateResults;
    procedure TestWritingIntegerArray;
    procedure TestWritingRealArray;
    procedure TestActiveDataSetUsed;
    procedure TestSaveTextRealArray;
    procedure TestSaveTextIntegerArray;
    procedure TestSaveBinaryRealArray;
    procedure TestSaveBinaryIntegerArray;
    procedure TestReuseBinaryResults;
  end;

implementation

uses
  System.IOUtils, System.SysUtils;

procedure TestTFootPrintGenerator.SetUp;
begin
  FFootPrintGenerator := TFootPrintGenerator.Create;
end;

procedure TestTFootPrintGenerator.TearDown;
begin
  FFootPrintGenerator.Free;
  FFootPrintGenerator := nil;
end;

procedure TestTFootPrintGenerator.TestActiveDataSetUsed;
var
  Capacity: TTwoDRealArray;
begin
  // TODO: Setup method call parameters
  FFootPrintGenerator.Settings.NumberOfRows := 1;
  FFootPrintGenerator.Settings.NumberOfColumns := 2;
  FFootPrintGenerator.Settings.DepthRateIndex[0,0] := 1;
  FFootPrintGenerator.Settings.DepthRateIndex[0,1] := 1;
  FFootPrintGenerator.Settings.CellSize := 1;
  FFootPrintGenerator.Settings.Active[0,0] := True;
  FFootPrintGenerator.Settings.Active[0,1] := False;

  // TODO: Validate method results
  Capacity := FFootPrintGenerator.Capacity;
  CheckEquals(1, Length(Capacity));
  CheckEquals(2, Length(Capacity[0]));
  CheckEquals(1,Capacity[0,0]);
  CheckEquals(0,Capacity[0,1]);
end;

procedure TestTFootPrintGenerator.TestCapacityCalculation;
const
  CellSize = 2;
  DepthRateIndex = 3;
begin
  FFootPrintGenerator.Settings.NumberOfRows := 1;
  FFootPrintGenerator.Settings.NumberOfColumns := 1;
  FFootPrintGenerator.Settings.CellSize := CellSize;
  FFootPrintGenerator.Settings.DepthRateIndex[0,0] := DepthRateIndex;
  CheckEquals(CellSize*DepthRateIndex, FFootPrintGenerator.Capacity[0,0]);
end;

procedure TestTFootPrintGenerator.TestComputeChangeForOneIteration;
var
  RowIndex: Integer;
  ColIndex: Integer;
  Withdrawals: TTwoDRealArray;
  NewValues: TTwoDRealArray;
  MaxExcessFraction: Double;
  Excess: double;
  WithDrawal: double;
  NeighborCount: TTwoDIntArray;
  CentralExcess: Double;
  IterationCount: Integer;
begin
  FFootPrintGenerator.Settings.NumberOfRows := 10;
  FFootPrintGenerator.Settings.NumberOfColumns := 10;
  FFootPrintGenerator.Settings.CellSize := 1;
  FFootPrintGenerator.Settings.MaxIterations := 1;
  FFootPrintGenerator.Settings.InitialDistribution := False;
  FFootPrintGenerator.Settings.RedistributionCriterion := 0;
  for RowIndex := 0 to FFootPrintGenerator.Settings.NumberOfRows - 1 do
  begin
    for ColIndex := 0 to FFootPrintGenerator.Settings.NumberOfColumns - 1 do
    begin
      FFootPrintGenerator.Settings.DepthRateIndex[RowIndex,ColIndex] := 1;
    end;
  end;
  WithDrawal := 9;
  FFootPrintGenerator.Settings.Withdrawals[5,5] := WithDrawal;
  Withdrawals := FFootPrintGenerator.Withdrawals;
  CheckEquals(WithDrawal, Withdrawals[5,5]);
  FFootPrintGenerator.DoInitialRedistribution(Withdrawals);
  NeighborCount := FFootPrintGenerator.NeighborCount;
  for RowIndex := 0 to FFootPrintGenerator.Settings.NumberOfRows - 1 do
  begin
    for ColIndex := 0 to FFootPrintGenerator.Settings.NumberOfColumns - 1 do
    begin
      if (RowIndex = 5) and (ColIndex = 5) then
      begin
        CheckEquals(WithDrawal, Withdrawals[RowIndex,ColIndex]);
      end
      else
      begin
        CheckEquals(0, Withdrawals[RowIndex,ColIndex]);
      end;
    end;
  end;

  NewValues := Withdrawals;
  SetLength(NewValues, FFootPrintGenerator.Settings.NumberOfRows,
    FFootPrintGenerator.Settings.NumberOfColumns);

  FFootPrintGenerator.RedistributeToNeighbors(
    FFootPrintGenerator.Settings.MaxIterations, Withdrawals, NewValues,
    MaxExcessFraction, IterationCount);

  Excess := (WithDrawal-1)/5;
  CentralExcess := WithDrawal - Excess*4;
  for RowIndex := 0 to FFootPrintGenerator.Settings.NumberOfRows - 1 do
  begin
    for ColIndex := 0 to FFootPrintGenerator.Settings.NumberOfColumns - 1 do
    begin
      if (RowIndex = 5) and (ColIndex = 5) then
      begin
        CheckEquals(CentralExcess, NewValues[RowIndex,ColIndex]);
      end
      else if ((RowIndex in [4,6]) and (ColIndex = 5))
        or (RowIndex = 5) and (ColIndex in [4,6]) then
      begin
        CheckEquals(Excess, NewValues[RowIndex,ColIndex]);
      end
      else
      begin
        CheckEquals(0, NewValues[RowIndex,ColIndex]);
      end;
    end;
  end;
end;

procedure TestTFootPrintGenerator.TestGenerateErrorIfWithdrawalsTooLarge;
begin
  CheckException(SetupGenerateErrorIfWithdrawalsTooLarge,
    EFootprintGenTooMuchWithdrawal, 'Failed to detect too much withdrawal');
end;

procedure TestTFootPrintGenerator.TestGenerateResults;
var
//  ListingFilename: string;
  InputFileName: string;
  AsciiFileFileName: string;
  BinaryFileName: string;
begin
  InputFileName := '..\..\..\TestFiles\TestModel.txt';
  FFootPrintGenerator.Settings.LoadFromFile(InputFileName);
  Assert(FFootPrintGenerator.Settings.ListingFileName <> '');

  ListingfileName := FFootPrintGenerator.Settings.ListingFileFullPath;
  AsciiFileFileName := FFootPrintGenerator.Settings.AsciiFileFullPath;
  if TFile.Exists(AsciiFileFileName) then
  begin
    TFile.Delete(AsciiFileFileName);
  end;
  BinaryFileName := FFootPrintGenerator.Settings.BinaryFileFullPath;
  if TFile.Exists(BinaryFileName) then
  begin
    TFile.Delete(BinaryFileName);
  end;
  FFootPrintGenerator.GenerateResults;
  CheckTrue(TFile.Exists(ListingfileName));
  CheckTrue(TFile.Exists(AsciiFileFileName));
  CheckTrue(TFile.Exists(BinaryFileName));
end;

procedure TestTFootPrintGenerator.SetupGenerateErrorIfWithdrawalsTooLarge;
var
  RowIndex: Integer;
  ColIndex: Integer;
  Withdrawals: TTwoDRealArray;
  Withdrawal: double;
begin
  FFootPrintGenerator.Settings.NumberOfRows := 10;
  FFootPrintGenerator.Settings.NumberOfColumns := 10;
  FFootPrintGenerator.Settings.CellSize := 1;
  for RowIndex := 0 to FFootPrintGenerator.Settings.NumberOfRows - 1 do
  begin
    for ColIndex := 0 to FFootPrintGenerator.Settings.NumberOfColumns - 1 do
    begin
      FFootPrintGenerator.Settings.DepthRateIndex[RowIndex,ColIndex] := 1;
    end;
  end;
  Withdrawal := 100000;
  FFootPrintGenerator.Settings.Withdrawals[5,5] := Withdrawal;
  Withdrawals := FFootPrintGenerator.Withdrawals;
  CheckEquals(Withdrawal, Withdrawals[5,5]);
  FFootPrintGenerator.DoInitialRedistribution(Withdrawals);
end;

procedure TestTFootPrintGenerator.SetupInvalidListingFile;
begin
  FFootPrintGenerator.Settings.ListingFileName := 'A:\RBWINST.txt';
  FFootPrintGenerator.GenerateResults;
end;

procedure TestTFootPrintGenerator.SetupInvalidListingFile2;
begin
  FFootPrintGenerator.Settings.ListingFileName := 'G:\RBWIN"ST.txt';
  FFootPrintGenerator.GenerateResults;
end;

procedure TestTFootPrintGenerator.SetupMissingListingFile;
begin
  FFootPrintGenerator.GenerateResults;
end;

procedure TestTFootPrintGenerator.TestIdentifyInitialNeighborHoods;
var
  RowIndex: Integer;
  ColIndex: Integer;
  Withdrawals: TTwoDRealArray;
  ErrorMessage: string;
begin
  FFootPrintGenerator.Settings.NumberOfRows := 10;
  FFootPrintGenerator.Settings.NumberOfColumns := 10;
  FFootPrintGenerator.Settings.CellSize := 1;
  for RowIndex := 0 to FFootPrintGenerator.Settings.NumberOfRows - 1 do
  begin
    for ColIndex := 0 to FFootPrintGenerator.Settings.NumberOfColumns - 1 do
    begin
      FFootPrintGenerator.Settings.DepthRateIndex[RowIndex,ColIndex] := 1;
    end;
  end;
  RowIndex := 1;
  for ColIndex := 1 to FFootPrintGenerator.Settings.NumberOfColumns - 1 do
  begin
    FFootPrintGenerator.Settings.DepthRateIndex[RowIndex,ColIndex] := 0;
  end;
  RowIndex := 3;
  for ColIndex := 1 to FFootPrintGenerator.Settings.NumberOfColumns - 1 do
  begin
    FFootPrintGenerator.Settings.DepthRateIndex[RowIndex,ColIndex] := 0;
  end;
  RowIndex := 5;
  for ColIndex := 1 to FFootPrintGenerator.Settings.NumberOfColumns - 1 do
  begin
    FFootPrintGenerator.Settings.DepthRateIndex[RowIndex,ColIndex] := 0;
  end;
  FFootPrintGenerator.Settings.Withdrawals[2,5] := 9;
  Withdrawals := FFootPrintGenerator.Withdrawals;
  CheckEquals(9, Withdrawals[2,5]);
  FFootPrintGenerator.DoInitialRedistribution(Withdrawals);
  for RowIndex := 0 to FFootPrintGenerator.Settings.NumberOfRows - 1 do
  begin
    for ColIndex := 0 to FFootPrintGenerator.Settings.NumberOfColumns - 1 do
    begin
      ErrorMessage := Format('Row: %0:d; Column: %1:d', [RowIndex,ColIndex]);
      if (RowIndex = 2) and (ColIndex in [4,5,6]) then
      begin
        CheckEquals(1, Withdrawals[RowIndex,ColIndex], ErrorMessage);
      end
      else if (RowIndex = 2) and (ColIndex in [3,7]) then
      begin
        CheckEquals(3, Withdrawals[RowIndex,ColIndex], ErrorMessage);
      end
      else
      begin
        CheckEquals(0, Withdrawals[RowIndex,ColIndex], ErrorMessage);
      end;
    end;
  end;
end;

procedure TestTFootPrintGenerator.TestIdentifyInitialNeighborHoodsWhenAppropriate;
var
  RowIndex: Integer;
  ColIndex: Integer;
  Withdrawals: TTwoDRealArray;
begin
  FFootPrintGenerator.Settings.NumberOfRows := 10;
  FFootPrintGenerator.Settings.NumberOfColumns := 10;
  FFootPrintGenerator.Settings.CellSize := 1;
  for RowIndex := 0 to FFootPrintGenerator.Settings.NumberOfRows - 1 do
  begin
    for ColIndex := 0 to FFootPrintGenerator.Settings.NumberOfColumns - 1 do
    begin
      FFootPrintGenerator.Settings.DepthRateIndex[RowIndex,ColIndex] := 1;
    end;
  end;
  FFootPrintGenerator.Settings.Withdrawals[5,5] := 9;
  FFootPrintGenerator.Settings.InitialDistribution := False;
  Withdrawals := FFootPrintGenerator.Withdrawals;
  CheckEquals(9, Withdrawals[5,5]);
  FFootPrintGenerator.DoInitialRedistribution(Withdrawals);
  for RowIndex := 0 to FFootPrintGenerator.Settings.NumberOfRows - 1 do
  begin
    for ColIndex := 0 to FFootPrintGenerator.Settings.NumberOfColumns - 1 do
    begin
      if (RowIndex = 5) and (ColIndex = 5) then
      begin
        CheckEquals(9, Withdrawals[RowIndex,ColIndex]);
      end
      else
      begin
        CheckEquals(0, Withdrawals[RowIndex,ColIndex]);
      end;
    end;
  end;
end;

procedure TestTFootPrintGenerator.TestInitialRedistribution;
var
  RowIndex: Integer;
  ColIndex: Integer;
  Withdrawals: TTwoDRealArray;
begin
  FFootPrintGenerator.Settings.NumberOfRows := 10;
  FFootPrintGenerator.Settings.NumberOfColumns := 10;
  FFootPrintGenerator.Settings.CellSize := 1;
  for RowIndex := 0 to FFootPrintGenerator.Settings.NumberOfRows - 1 do
  begin
    for ColIndex := 0 to FFootPrintGenerator.Settings.NumberOfColumns - 1 do
    begin
      FFootPrintGenerator.Settings.DepthRateIndex[RowIndex,ColIndex] := 1;
    end;
  end;
  FFootPrintGenerator.Settings.Withdrawals[5,5] := 9;
  Withdrawals := FFootPrintGenerator.Withdrawals;
  CheckEquals(9, Withdrawals[5,5]);
  FFootPrintGenerator.DoInitialRedistribution(Withdrawals);
  for RowIndex := 0 to FFootPrintGenerator.Settings.NumberOfRows - 1 do
  begin
    for ColIndex := 0 to FFootPrintGenerator.Settings.NumberOfColumns - 1 do
    begin
      if (RowIndex in [4,5,6]) and (ColIndex in [4,5,6]) then
      begin
        CheckEquals(1, Withdrawals[RowIndex,ColIndex]);
      end
      else
      begin
        CheckEquals(0, Withdrawals[RowIndex,ColIndex]);
      end;
    end;
  end;
end;

procedure TestTFootPrintGenerator.TestInitialRedistributionSingleCell;
var
  RowIndex: Integer;
  ColIndex: Integer;
  Withdrawals: TTwoDRealArray;
  Withdrawal: double;
begin
  FFootPrintGenerator.Settings.NumberOfRows := 10;
  FFootPrintGenerator.Settings.NumberOfColumns := 10;
  FFootPrintGenerator.Settings.CellSize := 1;
  for RowIndex := 0 to FFootPrintGenerator.Settings.NumberOfRows - 1 do
  begin
    for ColIndex := 0 to FFootPrintGenerator.Settings.NumberOfColumns - 1 do
    begin
      FFootPrintGenerator.Settings.DepthRateIndex[RowIndex,ColIndex] := 1;
    end;
  end;
  Withdrawal := 1.1;
  FFootPrintGenerator.Settings.Withdrawals[5,5] := Withdrawal;
  Withdrawals := FFootPrintGenerator.Withdrawals;
  CheckEquals(Withdrawal, Withdrawals[5,5]);
  FFootPrintGenerator.DoInitialRedistribution(Withdrawals);
  for RowIndex := 0 to FFootPrintGenerator.Settings.NumberOfRows - 1 do
  begin
    for ColIndex := 0 to FFootPrintGenerator.Settings.NumberOfColumns - 1 do
    begin
      if (RowIndex = 5) and (ColIndex = 5) then
      begin
        CheckEquals(Withdrawal, Withdrawals[RowIndex,ColIndex]);
      end
      else
      begin
        CheckEquals(0, Withdrawals[RowIndex,ColIndex]);
      end;
    end;
  end;
end;

procedure TestTFootPrintGenerator.TestInvalidListingFile;
begin
  CheckException(SetupInvalidListingFile,
    EDirectoryNotFoundException, 'Failed to detect invalid listing file');
end;

procedure TestTFootPrintGenerator.TestInvalidListingFile2;
begin
  CheckException(SetupInvalidListingFile2,
    EArgumentException, 'Failed to detect invalid listing file');
end;

procedure TestTFootPrintGenerator.TestMissingListingFile;
begin
  CheckException(SetupMissingListingFile,
    EFootprintGenNoListingFile, 'Failed to detect missing listing file');
end;

procedure TestTFootPrintGenerator.TestLoadFromFile;
var
  FileName: string;
begin
  FileName := '..\..\..\TestFiles\TestOpen.txt';
  // TODO: Setup method call parameters
  FFootPrintGenerator.LoadFromFile(FileName);
  // TODO: Validate method results
  CheckEquals(5, FFootPrintGenerator.Settings.NumberOfRows);
//  CheckTrue(False, 'Validation has not been set up yet.');
end;

procedure TestTFootPrintGenerator.TestRedistributeToPerimeter;
var
  RowIndex: Integer;
  ColIndex: Integer;
  Withdrawals: TTwoDRealArray;
  NewValues: TTwoDRealArray;
  MaxExcessFraction: Double;
//  Excess: double;
  WithDrawal: double;
  NeighborCount: TTwoDIntArray;
  ErrorMessage: string;
  IterationCount: Integer;
  TotalWithdrawal: double;
  DistributedExcess: Extended;
//  CentralExcess: Double;
begin
  FFootPrintGenerator.Settings.NumberOfRows := 10;
  FFootPrintGenerator.Settings.NumberOfColumns := 10;
  FFootPrintGenerator.Settings.CellSize := 1;
  FFootPrintGenerator.Settings.MaxIterations := 1;
  FFootPrintGenerator.Settings.InitialDistribution := False;
  FFootPrintGenerator.Settings.RedistributionCriterion := 1;
  for RowIndex := 0 to FFootPrintGenerator.Settings.NumberOfRows - 1 do
  begin
    for ColIndex := 0 to FFootPrintGenerator.Settings.NumberOfColumns - 1 do
    begin
      FFootPrintGenerator.Settings.DepthRateIndex[RowIndex,ColIndex] := 1;
    end;
  end;
  WithDrawal := 17;
  Withdrawals := FFootPrintGenerator.Withdrawals;
  for RowIndex := 3 to 7 do
  begin
    for ColIndex := 3 to 7 do
    begin
      Withdrawals[RowIndex,ColIndex] := 1;
    end;
  end;
  for RowIndex := 4 to 6 do
  begin
    for ColIndex := 4 to 6 do
    begin
      Withdrawals[RowIndex,ColIndex] := 2;
    end;
  end;
  Withdrawals[5,5] := WithDrawal;

  TotalWithdrawal := 0;
  for RowIndex := 0 to FFootPrintGenerator.Settings.NumberOfRows - 1 do
  begin
    for ColIndex := 0 to FFootPrintGenerator.Settings.NumberOfColumns - 1 do
    begin
      TotalWithdrawal := TotalWithdrawal
        + Withdrawals[RowIndex,ColIndex];
    end;
  end;
  DistributedExcess := (TotalWithdrawal-25)/12;
//  CheckEquals(WithDrawal, Withdrawals[5,5]);
  FFootPrintGenerator.DoInitialRedistribution(Withdrawals);
  NeighborCount := FFootPrintGenerator.NeighborCount;
//  for RowIndex := 0 to FFootPrintGenerator.Settings.NumberOfRows - 1 do
//  begin
//    for ColIndex := 0 to FFootPrintGenerator.Settings.NumberOfColumns - 1 do
//    begin
//      if (RowIndex = 5) and (ColIndex = 5) then
//      begin
//        CheckEquals(WithDrawal, Withdrawals[RowIndex,ColIndex]);
//      end
//      else
//      begin
//        CheckEquals(0, Withdrawals[RowIndex,ColIndex]);
//      end;
//    end;
//  end;

  NewValues := Withdrawals;
  SetLength(NewValues, FFootPrintGenerator.Settings.NumberOfRows,
    FFootPrintGenerator.Settings.NumberOfColumns);

  FFootPrintGenerator.RedistributeToPerimeter(
    FFootPrintGenerator.Settings.NumberOfColumns-1,
    FFootPrintGenerator.Settings.NumberOfRows-1, Withdrawals, NewValues);

//  Excess := (WithDrawal-1)/5;
//  CentralExcess := WithDrawal - Excess*4;
  for RowIndex := 0 to FFootPrintGenerator.Settings.NumberOfRows - 1 do
  begin
    for ColIndex := 0 to FFootPrintGenerator.Settings.NumberOfColumns - 1 do
    begin
      ErrorMessage := Format('Row: %0:d; Column: %1:d', [RowIndex,ColIndex]);
      if (RowIndex in [4,5,6]) and (ColIndex  in [4,5,6]) then
      begin
        CheckEquals(1, NewValues[RowIndex,ColIndex], ErrorMessage);
      end
      else if ((RowIndex in [3,7]) and (ColIndex in [4,5,6])) then
      begin
        CheckEquals(1+DistributedExcess, NewValues[RowIndex,ColIndex], ErrorMessage);
      end
      else if ((RowIndex in [4,5,6]) and (ColIndex in [3,7])) then
      begin
        CheckEquals(1+DistributedExcess, NewValues[RowIndex,ColIndex], ErrorMessage);
      end
      else if ((RowIndex in [3,7]) and (ColIndex in [3,7])) then
      begin
        CheckEquals(1, NewValues[RowIndex,ColIndex], ErrorMessage);
      end
      else
      begin
        CheckEquals(0, NewValues[RowIndex,ColIndex], ErrorMessage);
      end;
    end;
  end;
end;

procedure TestTFootPrintGenerator.TestRetrieveWithdrawals;
var
  RowIndex: Integer;
  ColIndex: Integer;
  Withdrawals: TTwoDRealArray;
begin
  FFootPrintGenerator.Settings.NumberOfRows := 10;
  FFootPrintGenerator.Settings.NumberOfColumns := 9;
  FFootPrintGenerator.Settings.Withdrawals[5,5] := 1;
  Withdrawals := FFootPrintGenerator.Withdrawals;
  CheckEquals(10, Length(Withdrawals));
  CheckEquals(9, Length(Withdrawals[0]));
  for RowIndex := 0 to FFootPrintGenerator.Settings.NumberOfRows - 1 do
  begin
    for ColIndex := 0 to FFootPrintGenerator.Settings.NumberOfColumns - 1 do
    begin
      if (RowIndex = 5) and (ColIndex = 5) then
      begin
        CheckEquals(1, Withdrawals[RowIndex, ColIndex]);
      end
      else
      begin
        CheckEquals(0, Withdrawals[RowIndex, ColIndex]);
      end;
    end;
  end;
end;

procedure TestTFootPrintGenerator.TestReuseBinaryResults;
var
  FileName: string;
  BinaryFileName: string;
  TestValue: Double;
begin
  FileName := '..\..\..\TestFiles\TestOpen2.txt';
  BinaryFileName := '..\..\..\TestFiles\PriorWithdrawals.fpb';
  if TFile.Exists(BinaryFileName) then
  begin
    TFile.Delete(BinaryFileName);
  end;
  FFootPrintGenerator.LoadFromFile(FileName);
  FFootPrintGenerator.GenerateResults;
  CheckTrue(TFile.Exists(BinaryFileName));
  FileName := '..\..\..\TestFiles\TestOpenBinary2.txt';
  FFootPrintGenerator.LoadFromFile(FileName);
  TestValue := 45.1128410141984;
  CheckTrue(Abs(TestValue - FFootPrintGenerator.Withdrawals[0,0]) < 1e-13);
//  CheckEquals(TestValue, FFootPrintGenerator.Withdrawals[0,0]);
end;

procedure TestTFootPrintGenerator.TestSaveBinaryIntegerArray;
var
  ArrayName: string;
  FileName: string;
//  AnnArray: TTwoDRealArray;
  Writer: TFileStream;
  Reader: TFileStream;
  ALength: longint;
  AText: array of Char;
//  AnArray: TTwoDRealArray;
  RowCount: longint;
  ColumnCount: Integer;
  AValue: integer;
  AnArray: TTwoDIntArray;
begin
  InitializeIntegerArray(AnArray);
  FileName := '..\..\..\TestFiles\TestSaveBinaryInteger.bin';
  ArrayName := 'test';
  Writer := TFile.Create(FileName);
  try
    FFootPrintGenerator.SaveBinaryIntegerArray(AnArray, Writer, ArrayName);
  finally
    Writer.Free;
  end;

  Reader := TFile.Open(FileName, TFileMode.fmOpen);
  try
    Reader.Read(ALength, SizeOf(ALength));
    CheckEquals(Length(ArrayName), ALength);
    SetLength(AText, ALength);
    Reader.Read(AText[0], ALength*SizeOf(Char));
    CheckEquals(string(AText), ArrayName);
    Reader.Read(RowCount, SizeOf(RowCount));
    CheckEquals(3, RowCount);
    Reader.Read(ColumnCount, SizeOf(ColumnCount));
    CheckEquals(2, ColumnCount);

    Reader.Read(AValue, SizeOf(AValue));
//    TestValue := 1.1;
    CheckEquals(1, AValue);

    Reader.Read(AValue, SizeOf(AValue));
//    TestValue := 2.2;
    CheckEquals(2, AValue);

    Reader.Read(AValue, SizeOf(AValue));
//    TestValue := 3.3;
    CheckEquals(3, AValue);

    Reader.Read(AValue, SizeOf(AValue));
//    TestValue := 4.4;
    CheckEquals(4, AValue);

    Reader.Read(AValue, SizeOf(AValue));
//    TestValue := 5.5;
    CheckEquals(5, AValue);

    Reader.Read(AValue, SizeOf(AValue));
//    TestValue := 6.6;
    CheckEquals(6, AValue);

    CheckEquals(Reader.Position, Reader.Size);
  finally
    Reader.Free;
  end;
end;

procedure TestTFootPrintGenerator.InitializeIntegerArray(var AnArray: TTwoDIntArray);
begin
  SetLength(AnArray, 3, 2);
  AnArray[0, 0] := 1;
  AnArray[0, 1] := 2;
  AnArray[1, 0] := 3;
  AnArray[1, 1] := 4;
  AnArray[2, 0] := 5;
  AnArray[2, 1] := 6;
end;

procedure TestTFootPrintGenerator.InitializeRealArray(var AnArray: TTwoDRealArray);
begin
  SetLength(AnArray, 3, 2);
  AnArray[0, 0] := 1.1;
  AnArray[0, 1] := 2.2;
  AnArray[1, 0] := 3.3;
  AnArray[1, 1] := 4.4;
  AnArray[2, 0] := 5.5;
  AnArray[2, 1] := 6.6;
end;

//procedure TestTFootPrintGenerator.TestSaveBinaryFile;
//var
//  FileName: string;
//begin
//  FileName := '..\..\..\TestFiles\Capacity.fpb';
//  if TFile.Exists(FileName) then
//  begin
//    TFile.Delete(FileName);
//  end;
//  FFootPrintGenerator.SaveABinaryFile(FileName);
//  CheckTrue(TFile.Exists(FileName));
//end;

procedure TestTFootPrintGenerator.TestSaveBinaryRealArray;
var
  ArrayName: string;
  FileName: string;
//  AnnArray: TTwoDRealArray;
  Writer: TFileStream;
  Reader: TFileStream;
  ALength: longint;
  AText: array of Char;
  AnArray: TTwoDRealArray;
  RowCount: longint;
  ColumnCount: Integer;
  AValue: Double;
  TestValue: double;
begin
  InitializeRealArray(AnArray);
  FileName := '..\..\..\TestFiles\TestSaveBinaryReal.bin';
  ArrayName := 'test';
  Writer := TFile.Create(FileName);
  try
    FFootPrintGenerator.SaveBinaryRealArray(AnArray, Writer, ArrayName);
  finally
    Writer.Free;
  end;

  Reader := TFile.Open(FileName, TFileMode.fmOpen);
  try
    Reader.Read(ALength, SizeOf(ALength));
    CheckEquals(Length(ArrayName), ALength);
    SetLength(AText, ALength);
    Reader.Read(AText[0], ALength*SizeOf(Char));
    CheckEquals(string(AText), ArrayName);
    Reader.Read(RowCount, SizeOf(RowCount));
    CheckEquals(3, RowCount);
    Reader.Read(ColumnCount, SizeOf(ColumnCount));
    CheckEquals(2, ColumnCount);

    Reader.Read(AValue, SizeOf(AValue));
    TestValue := 1.1;
    CheckEquals(TestValue, AValue);

    Reader.Read(AValue, SizeOf(AValue));
    TestValue := 2.2;
    CheckEquals(TestValue, AValue);

    Reader.Read(AValue, SizeOf(AValue));
    TestValue := 3.3;
    CheckEquals(TestValue, AValue);

    Reader.Read(AValue, SizeOf(AValue));
    TestValue := 4.4;
    CheckEquals(TestValue, AValue);

    Reader.Read(AValue, SizeOf(AValue));
    TestValue := 5.5;
    CheckEquals(TestValue, AValue);

    Reader.Read(AValue, SizeOf(AValue));
    TestValue := 6.6;
    CheckEquals(TestValue, AValue);

    CheckEquals(Reader.Position, Reader.Size);
  finally
    Reader.Free;
  end;
end;

procedure TestTFootPrintGenerator.TestSaveTextIntegerArray;
var
  ArrayName: string;
  FileName: string;
  Writer: TStreamWriter;
  AnArray: TTwoDIntArray;
  Reader: TStreamReader;
  Splitter: TStringList;
  ALine: string;
begin
  InitializeIntegerArray(AnArray);
  ArrayName := 'Test';
  FileName := '..\..\..\TestFiles\TestSaveAsciiInteger.txt';
  Writer := TFile.CreateText(FileName);
  try
    FFootPrintGenerator.SaveTextIntegerArray(AnArray, Writer, ArrayName);
  finally
    Writer.Free;
  end;

  Reader := TFile.OpenText(FileName);
  Splitter := TStringList.Create;
  try
    CheckEquals(ArrayName, Reader.ReadLine);

    ALine := Reader.ReadLine;
    CheckEquals('3',ALine);
    ALine := Reader.ReadLine;
    CheckEquals('2',ALine);

    Splitter.CommaText := Reader.ReadLine;
    CheckEquals(2,Splitter.Count);
    CheckEquals('1',Splitter[0]);
    CheckEquals('2',Splitter[1]);
    Splitter.CommaText := Reader.ReadLine;
    CheckEquals(2,Splitter.Count);
    CheckEquals('3',Splitter[0]);
    CheckEquals('4',Splitter[1]);
    Splitter.CommaText := Reader.ReadLine;
    CheckEquals(2,Splitter.Count);
    CheckEquals('5',Splitter[0]);
    CheckEquals('6',Splitter[1]);
    CheckTrue(Reader.EndOfStream);
  finally
    Reader.Free;
    Splitter.Free;
  end;
end;

procedure TestTFootPrintGenerator.TestSaveTextRealArray;
var
  AnArray: TTwoDRealArray;
  Writer: TStreamWriter;
  ArrayName: string;
  FileName: string;
  Reader: TStreamReader;
  Splitter: TStringList;
  ALine: string;
begin
  InitializeRealArray(AnArray);
  ArrayName := 'Test';
  FileName := '..\..\..\TestFiles\TestSaveAsciiReal.txt';
  Writer := TFile.CreateText(FileName);
  try
    FFootPrintGenerator.SaveTextRealArray(AnArray, Writer, ArrayName);
  finally
    Writer.Free;
  end;

  Reader := TFile.OpenText(FileName);
  Splitter := TStringList.Create;
  try
    CheckEquals(ArrayName, Reader.ReadLine);
    ALine := Reader.ReadLine;
    CheckEquals('3',ALine);
    ALine := Reader.ReadLine;
    CheckEquals('2',ALine);

    Splitter.CommaText := Reader.ReadLine;
    CheckEquals(2,Splitter.Count);
    CheckEquals('1.1',Splitter[0]);
    CheckEquals('2.2',Splitter[1]);
    Splitter.CommaText := Reader.ReadLine;
    CheckEquals(2,Splitter.Count);
    CheckEquals('3.3',Splitter[0]);
    CheckEquals('4.4',Splitter[1]);
    Splitter.CommaText := Reader.ReadLine;
    CheckEquals(2,Splitter.Count);
    CheckEquals('5.5',Splitter[0]);
    CheckEquals('6.6',Splitter[1]);
    CheckTrue(Reader.EndOfStream);
  finally
    Reader.Free;
    Splitter.Free;
  end;
end;

procedure TestTFootPrintGenerator.TestSetupNeighborCount;
var
  RowIndex: Integer;
  ColIndex: Integer;
  NeighborCount: TTwoDIntArray;
begin
  FFootPrintGenerator.Settings.NumberOfRows := 4;
  FFootPrintGenerator.Settings.NumberOfColumns := 4;
  FFootPrintGenerator.Settings.CellSize := 1;
  for RowIndex := 0 to FFootPrintGenerator.Settings.NumberOfRows - 1 do
  begin
    for ColIndex := 0 to FFootPrintGenerator.Settings.NumberOfColumns - 1 do
    begin
      FFootPrintGenerator.Settings.DepthRateIndex[RowIndex,ColIndex] := 1;
    end;
  end;
  NeighborCount := FFootPrintGenerator.NeighborCount;
  for RowIndex := 0 to FFootPrintGenerator.Settings.NumberOfRows - 1 do
  begin
    for ColIndex := 0 to FFootPrintGenerator.Settings.NumberOfColumns - 1 do
    begin
      if (RowIndex = 0) and (ColIndex = 0) then
      begin
        CheckEquals(2,NeighborCount[RowIndex,ColIndex]);
      end
      else if (RowIndex = FFootPrintGenerator.Settings.NumberOfRows - 1)
        and (ColIndex = 0) then
      begin
        CheckEquals(2,NeighborCount[RowIndex,ColIndex]);
      end
      else if (RowIndex = 0)
        and (ColIndex = FFootPrintGenerator.Settings.NumberOfColumns - 1) then
      begin
        CheckEquals(2,NeighborCount[RowIndex,ColIndex]);
      end
      else if (RowIndex = FFootPrintGenerator.Settings.NumberOfRows - 1)
        and (ColIndex = FFootPrintGenerator.Settings.NumberOfColumns - 1) then
      begin
        CheckEquals(2,NeighborCount[RowIndex,ColIndex]);
      end
      else if (RowIndex > 0) and (ColIndex > 0)
        and (RowIndex < FFootPrintGenerator.Settings.NumberOfRows - 1)
        and (ColIndex < FFootPrintGenerator.Settings.NumberOfColumns - 1) then
      begin
        CheckEquals(4,NeighborCount[RowIndex,ColIndex]);
      end
      else
      begin
        CheckEquals(3,NeighborCount[RowIndex,ColIndex]);
      end;
    end;
  end;
end;

procedure TestTFootPrintGenerator.TestWritingIntegerArray;
var
  FileName: string;
  OutputFile: TStreamWriter;
  AnArray: TTwoDIntArray;
  RowIndex: integer;
  ColIndex: integer;
begin
  FileName := '..\..\..\TestFiles\TestIntegerFile.txt';
  if FileExists(FileName) then
  begin
    DeleteFile(FileName);
  end;
  OutputFile := TFile.CreateText(FileName);
  try
    SetLength(AnArray, 5, 29);
    for RowIndex := 0 to 5 - 1 do
    begin
      for ColIndex := 0 to 29 - 1 do
      begin
        AnArray[RowIndex,ColIndex] := RowIndex*ColIndex;
      end;
    end;
    FFootPrintGenerator.WriteIntegerArray(AnArray, OutputFile);
  finally
    OutputFile.Free
  end;
  CheckTrue(FileExists(FileName));

end;

procedure TestTFootPrintGenerator.TestWritingRealArray;
var
  FileName: string;
  OutputFile: TStreamWriter;
  AnArray: TTwoDRealArray;
  RowIndex: integer;
  ColIndex: integer;
begin
  FileName := '..\..\..\TestFiles\TestRealFile.txt';
  if FileExists(FileName) then
  begin
    DeleteFile(FileName);
  end;
  OutputFile := TFile.CreateText(FileName);
  try
    SetLength(AnArray, 5, 29);
    for RowIndex := 0 to 5 - 1 do
    begin
      for ColIndex := 0 to 29 - 1 do
      begin
        AnArray[RowIndex,ColIndex] := (RowIndex+0.1)*(ColIndex+0.1);
      end;
    end;
    FFootPrintGenerator.WriteRealArray(AnArray, OutputFile);
  finally
    OutputFile.Free
  end;
  CheckTrue(FileExists(FileName));

end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTFootPrintGenerator.Suite);
end.

