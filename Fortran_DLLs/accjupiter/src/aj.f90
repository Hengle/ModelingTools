! Access-Jupiter (AJ) Library
!
! Code for DLL (accjupiter.dll) to allow ModelMate 
!   (written in Delphi) to access JUPITER API functionality.  
!
! Limitations:
!   Delphi cannot access module procedures (and so cannot invoke
!      JUPITER API routines directly).
!   Lahey LF95 does not support functions that return CHARACTER data.
!   No optional arguments may be used.
!   All CHARACTER arguments should be declared as (LEN=*).
!   Haven't found a way to pass LOGICAL/boolean in arg. list.
!     Instead, use INTEGER/LongInt in arg. list and LOG2INT/LongInt2Bool
!     See aj_mod.f90 and Utilities Unit.
!   Arguments should be INTENT(INOUT) by declaration or by default.
!
!  !DEC$ ATTRIBUTES DLLEXPORT::NAME
!  !DEC$ ATTRIBUTES ALIAS:'name' :: NAME
!
!
!###############################################################################
!
SUBROUTINE AJ_GET_CHARACTER_BY_KEYWORD(KEYWORD, INDX, CVALUE);
  !DEC$ ATTRIBUTES DLLEXPORT::AJ_GET_CHARACTER_BY_KEYWORD
  !DEC$ ATTRIBUTES ALIAS:'aj_get_character_by_keyword' :: AJ_GET_CHARACTER_BY_KEYWORD
  USE UTILITIES
  USE UCODE_DATA, ONLY: PARNAM, GROUPNAME, DERPARNAME, DERPAREQN, DEROBSEQN, &
                        PREDGROUPNAME, PREDNAME, DERPREDEQN, GROUPNPRED, &
                        PRIGROUPNAME, PRICOVMATNAM, PRIORNAME, PRIEQN, &
                        GROUPNPRI, GPPRIEQN, GPSTATFLAG, STATFLAG, &
                        GPMEASSTATFLAG, MEASSTATFLAG, GPPRISTATFLAG, &
                        PRISTATFLAG
  USE DEPENDENTS, ONLY: COVMATNAM, GROUPNAM, GROUPNOBS, OBSALLNAM
  USE MODEL_IO, ONLY: INSFILE, MODINFILE, MODOUTFILE, TEMPFILE
  USE PARALLEL_DATA, ONLY: RUNNERNAME, RUNNERDIR
  USE AJ_MOD
  IMPLICIT NONE
  CHARACTER(LEN=*), INTENT(INOUT) :: KEYWORD
  INTEGER,          INTENT(INOUT) :: INDX
  CHARACTER(LEN=*), INTENT(INOUT) :: CVALUE
  INTEGER :: I, IERR
  CHARACTER(LEN=256) :: FKEY, UPKEY, TEMPVAL, ERRMSG
  !
  IERR = 0
  CVALUE = ''
  I = INDX + 1  ! Convert from 0-based to 1-based indexing
  FKEY = ' '
  CALL DSTRING2CHAR(KEYWORD,FKEY,IERR)
!  write(8,10)trim(fkey),i
  10 format(' in AJ_GET_CHARACTER_BY_KEYWORD, fkey i = ',a,1x,i5)
!  IF (IERR == 0) THEN
    CALL UTL_CASE(FKEY,UPKEY,1)
    SELECT CASE (UPKEY)
      ! Parameters
      CASE ('PARAMNAME')
        IF (I > 0 .AND. I .LE. UBOUND(PARNAM,1)) TEMPVAL = PARNAM(I)
      CASE ('PARGROUPNAME')
        IF (I > 0 .AND. I .LE. UBOUND(GROUPNAME,1)) TEMPVAL = GROUPNAME(I)
      CASE ('DERPARNAME')
        IF (I > 0 .AND. I .LE. UBOUND(DERPARNAME,1)) TEMPVAL = DERPARNAME(I)
      CASE ('DERPAREQN')
        IF (I > 0 .AND. I .LE. UBOUND(DERPAREQN,1)) TEMPVAL = DERPAREQN(I)
      ! Observations
      CASE ('OBSGROUPNAME')
        IF (I > 0 .AND. I .LE. UBOUND(GROUPNAM,1)) TEMPVAL = GROUPNAM(I)
      CASE ('COVMATRIX')
        IF (I > 0 .AND. I .LE. UBOUND(COVMATNAM,1)) TEMPVAL = COVMATNAM(I)
      CASE ('OBSNAME')
        IF (I > 0 .AND. I .LE. UBOUND(OBSALLNAM,1)) TEMPVAL = OBSALLNAM(I)
      CASE ('GROUPNOBS')
        IF (I > 0 .AND. I .LE. UBOUND(GROUPNOBS,1)) TEMPVAL = GROUPNOBS(I)
      CASE ('DEROBSEQN')
        IF (I > 0 .AND. I .LE. UBOUND(DEROBSEQN,1)) TEMPVAL = DEROBSEQN(I)
      CASE ('GPSTATFLAG')
        IF (I > 0 .AND. I .LE. UBOUND(GPSTATFLAG,1)) TEMPVAL = GPSTATFLAG(I)
      CASE ('STATFLAG')
        IF (I > 0 .AND. I .LE. UBOUND(STATFLAG,1)) TEMPVAL = STATFLAG(I)
      ! Predictions
      CASE ('PREDGROUPNAME')
        IF (I > 0 .AND. I .LE. UBOUND(PREDGROUPNAME,1)) TEMPVAL = PREDGROUPNAME(I)
      CASE ('PREDNAME')
        IF (I > 0 .AND. I .LE. UBOUND(PREDNAME,1)) TEMPVAL = PREDNAME(I)
      CASE ('GROUPNPRED')
        IF (I > 0 .AND. I .LE. UBOUND(GROUPNPRED,1)) TEMPVAL = GROUPNPRED(I)
      CASE ('DERPREDEQUATION')
        IF (I > 0 .AND. I .LE. UBOUND(DERPREDEQN,1)) TEMPVAL = DERPREDEQN(I)
      CASE ('GPMEASSTATFLAG')
        IF (I > 0 .AND. I .LE. UBOUND(GPMEASSTATFLAG,1)) TEMPVAL = GPMEASSTATFLAG(I)
      CASE ('MEASSTATFLAG')
        IF (I > 0 .AND. I .LE. UBOUND(MEASSTATFLAG,1)) TEMPVAL = MEASSTATFLAG(I)
      ! Prior Information
      CASE ('PRIGROUPNAME')
        IF (I > 0 .AND. I .LE. UBOUND(PRIGROUPNAME,1)) TEMPVAL = PRIGROUPNAME(I)
      CASE ('PRICOVMATRIX')
        IF (I > 0 .AND. I .LE. UBOUND(PRICOVMATNAM,1)) TEMPVAL = PRICOVMATNAM(I)
      CASE ('GPPRIEQN')
        IF (I > 0 .AND. I .LE. UBOUND(GPPRIEQN,1)) TEMPVAL = GPPRIEQN(I)        
      CASE ('PRIORNAME')
        IF (I > 0 .AND. I .LE. UBOUND(PRIORNAME,1)) TEMPVAL = PRIORNAME(I)
      CASE ('PRIEQN')
        IF (I > 0 .AND. I .LE. UBOUND(PRIEQN,1)) TEMPVAL = PRIEQN(I)
      CASE ('GROUPNPRI')
        IF (I > 0 .AND. I .LE. UBOUND(GROUPNPRI,1)) TEMPVAL = GROUPNPRI(I)
      CASE ('GPPRISTATFLAG')
        IF (I > 0 .AND. I .LE. UBOUND(GPPRISTATFLAG,1)) TEMPVAL = GPPRISTATFLAG(I)
      CASE ('PRISTATFLAG')
        IF (I > 0 .AND. I .LE. UBOUND(PRISTATFLAG,1)) TEMPVAL = PRISTATFLAG(I)
      ! Model IO
      CASE ('MODINFILE')
        IF (I > 0 .AND. I .LE. UBOUND(MODINFILE,1)) TEMPVAL = MODINFILE(I)
      CASE ('TEMPLATEFILE')
        IF (I > 0 .AND. I .LE. UBOUND(TEMPFILE,1)) TEMPVAL = TEMPFILE(I)
      CASE ('MODOUTFILE')
        IF (I > 0 .AND. I .LE. UBOUND(MODOUTFILE,1)) TEMPVAL = MODOUTFILE(I)
      CASE ('INSTRUCTIONFILE')
        IF (I > 0 .AND. I .LE. UBOUND(INSFILE,1)) TEMPVAL = INSFILE(I)
      ! Parallel processing
      CASE ('RUNNERNAME')
        IF (I > 0 .AND. I .LE. UBOUND(RUNNERNAME,1)) TEMPVAL = RUNNERNAME(I)
      CASE ('RUNNERDIR')
        IF (I > 0 .AND. I .LE. UBOUND(RUNNERDIR,1)) TEMPVAL = RUNNERDIR(I)
      CASE DEFAULT
        TEMPVAL = 'KeyNotFound'
    END SELECT
    CALL CHAR2DSTRING(TEMPVAL,CVALUE,IERR)
!  ENDIF
  RETURN
END SUBROUTINE AJ_GET_CHARACTER_BY_KEYWORD
!
!###############################################################################
!
SUBROUTINE AJ_GET_DOUBLE_BY_KEYWORD(KEYWORD, INDX, DVALUE);
  !DEC$ ATTRIBUTES DLLEXPORT::AJ_GET_DOUBLE_BY_KEYWORD
  !DEC$ ATTRIBUTES ALIAS:'aj_get_double_by_keyword' :: AJ_GET_DOUBLE_BY_KEYWORD
  USE GLOBAL_DATA, ONLY: BIGREAL
  USE UTILITIES
  USE DEPENDENTS, ONLY: WTMULTIPLIER, OBSVAL
  USE UCODE_DATA
  USE PARALLEL_DATA, ONLY: RUNTIME
  USE AJ_MOD
  IMPLICIT NONE
  CHARACTER(LEN=*), INTENT(INOUT) :: KEYWORD
  INTEGER,          INTENT(INOUT) :: INDX
  DOUBLE PRECISION, INTENT(INOUT) :: DVALUE
  INTEGER :: I, IERR
  CHARACTER(LEN=256) :: FKEY, UPKEY
  !
  DVALUE = BIGREAL
  I = INDX + 1  ! Convert from 0-based to 1-based indexing
  CALL DSTRING2CHAR(KEYWORD,FKEY,IERR)
!  write(8,10)trim(fkey),i
  10 format(' in AJ_GET_DOUBLE_BY_KEYWORD, fkey i = ',a,1x,i5)
!  IF (IERR == 0) THEN
    CALL UTL_CASE(FKEY,UPKEY,1)
    SELECT CASE (UPKEY)
      ! Parameters
      CASE ('GPLOWERVALUE')
        IF (I > 0 .AND. I .LE. UBOUND(GPLOWERVALUE,1)) DVALUE = GPLOWERVALUE(I)
      CASE ('GPUPPERVALUE')
        IF (I > 0 .AND. I .LE. UBOUND(GPUPPERVALUE,1)) DVALUE = GPUPPERVALUE(I)
      CASE ('GPLOWERCONSTRAINT')
        IF (I > 0 .AND. I .LE. UBOUND(GPLOWERCONSTRAINT,1)) DVALUE = GPLOWERCONSTRAINT(I)
      CASE ('GPUPPERCONSTRAINT')
        IF (I > 0 .AND. I .LE. UBOUND(GPUPPERCONSTRAINT,1)) DVALUE = GPUPPERCONSTRAINT(I)
      CASE ('GPPERTURBAMT')
        IF (I > 0 .AND. I .LE. UBOUND(GPPERTURBAMT,1)) DVALUE = GPPERTURBAMT(I)
      CASE ('GPTOLPAR')
        IF (I > 0 .AND. I .LE. UBOUND(GPTOLPAR,1)) DVALUE = GPTOLPAR(I)
      CASE ('GPMAXCHANGE')
        IF (I > 0 .AND. I .LE. UBOUND(GPMAXCHANGE,1)) DVALUE = GPMAXCHANGE(I)
      CASE ('GPSCALEPVAL')
        IF (I > 0 .AND. I .LE. UBOUND(GPSCALEPVAL,1)) DVALUE = GPSCALEPVAL(I)
      CASE ('STARTVALUE')
        IF (I > 0 .AND. I .LE. UBOUND(STARTVALUE,1)) DVALUE = STARTVALUE(I)
      CASE ('LOWERVALUE')
        IF (I > 0 .AND. I .LE. UBOUND(LOWERVALUE,1)) DVALUE = LOWERVALUE(I)
      CASE ('UPPERVALUE')
        IF (I > 0 .AND. I .LE. UBOUND(UPPERVALUE,1)) DVALUE = UPPERVALUE(I)
      CASE ('LOWERCONSTRAINT')
        IF (I > 0 .AND. I .LE. UBOUND(LOWERCONSTRAINT,1)) DVALUE = LOWERCONSTRAINT(I)
      CASE ('UPPERCONSTRAINT')
        IF (I > 0 .AND. I .LE. UBOUND(UPPERCONSTRAINT,1)) DVALUE = UPPERCONSTRAINT(I)
      CASE ('PERTURBAMT')
        IF (I > 0 .AND. I .LE. UBOUND(PERTURBAMT,1)) DVALUE = PERTURBAMT(I)
      CASE ('TOLPAR')
        IF (I > 0 .AND. I .LE. UBOUND(TOLPAR,1)) DVALUE = TOLPAR(I)
      CASE ('MAXCHANGE')
        IF (I > 0 .AND. I .LE. UBOUND(MAXCHANGE,1)) DVALUE = MAXCHANGE(I)
      CASE ('SCALEPVAL')
        IF (I > 0 .AND. I .LE. UBOUND(SCALEPVAL,1)) DVALUE = SCALEPVAL(I)
      ! Observations
      CASE ('WTMULTIPLIER')
        IF (I > 0 .AND. I .LE. UBOUND(WTMULTIPLIER,1)) DVALUE = WTMULTIPLIER(I)
      CASE ('GPSTATISTIC')
        IF (I > 0 .AND. I .LE. UBOUND(GPSTATISTIC,1)) DVALUE = GPSTATISTIC(I)
      CASE ('GPWTOSCONSTANT')
        IF (I > 0 .AND. I .LE. UBOUND(GPWTOSCONSTANT,1)) DVALUE = GPWTOSCONSTANT(I)
      CASE ('OBSVALUE')
        IF (I > 0 .AND. I .LE. UBOUND(OBSVAL,1)) DVALUE = OBSVAL(I)
      CASE ('STATISTIC')
        IF (I > 0 .AND. I .LE. UBOUND(STATISTIC,1)) DVALUE = STATISTIC(I)
      CASE ('WTOSCONSTANT')
        IF (I > 0 .AND. I .LE. UBOUND(WTOSCONSTANT,1)) DVALUE = WTOSCONSTANT(I)
      ! Predictions
      CASE ('GPREFVALUE')
        IF (I > 0 .AND. I .LE. UBOUND(GPREFVALUE,1)) DVALUE = GPREFVALUE(I)
      CASE ('GPMEASSTATISTIC')
        IF (I > 0 .AND. I .LE. UBOUND(GPMEASSTATISTIC,1)) DVALUE = GPMEASSTATISTIC(I)
      CASE ('REFVALUE')
        IF (I > 0 .AND. I .LE. UBOUND(REFVALUE,1)) DVALUE = REFVALUE(I)
      CASE ('MEASSTATISTIC')
        IF (I > 0 .AND. I .LE. UBOUND(MEASSTATISTIC,1)) DVALUE = MEASSTATISTIC(I)
      ! Prior Information
      CASE ('PRIWTMULTIPLIER')
        IF (I > 0 .AND. I .LE. UBOUND(PRIWTMULTIPLIER,1)) DVALUE = PRIWTMULTIPLIER(I)
      CASE ('GPPRIORINFOVALUE')
        IF (I > 0 .AND. I .LE. UBOUND(GPPRIORINFOVALUE,1)) DVALUE = GPPRIORINFOVALUE(I)
      CASE ('GPPRISTATISTIC')
        IF (I > 0 .AND. I .LE. UBOUND(GPPRISTATISTIC,1)) DVALUE = GPPRISTATISTIC(I)
      CASE ('PRIORINFOVALUE')
        IF (I > 0 .AND. I .LE. UBOUND(PRIORINFOVALUE,1)) DVALUE = PRIORINFOVALUE(I)
      CASE ('PRISTATISTIC')
        IF (I > 0 .AND. I .LE. UBOUND(PRISTATISTIC,1)) DVALUE = PRISTATISTIC(I)
      ! Parallel processing
      CASE ('RUNTIME')
        IF (I > 0 .AND. I .LE. UBOUND(RUNTIME,1)) DVALUE = RUNTIME(I)
      CASE DEFAULT
        DVALUE = -BIGREAL
    END SELECT
!  ENDIF
  RETURN
END SUBROUTINE AJ_GET_DOUBLE_BY_KEYWORD
!
!###############################################################################
!
SUBROUTINE AJ_GET_INTEGER_BY_KEYWORD(KEYWORD, INDX, IVALUE);
  !DEC$ ATTRIBUTES DLLEXPORT::AJ_GET_INTEGER_BY_KEYWORD
  !DEC$ ATTRIBUTES ALIAS:'aj_get_integer_by_keyword' :: AJ_GET_INTEGER_BY_KEYWORD
  USE GLOBAL_DATA, ONLY: BIGINTEGER
  USE UTILITIES
  USE DEPENDENTS, ONLY: PLOTSYMBOL
  USE UCODE_DATA
  USE AJ_MOD
  IMPLICIT NONE
  CHARACTER(LEN=*), INTENT(INOUT) :: KEYWORD
  INTEGER,          INTENT(INOUT) :: INDX
  INTEGER,          INTENT(INOUT) :: IVALUE
  INTEGER :: I, IERR
  CHARACTER(LEN=256) :: FKEY, UPKEY
  !
  IVALUE = BIGINTEGER
  I = INDX + 1  ! Convert from 0-based to 1-based indexing
  FKEY = ' '
  CALL DSTRING2CHAR(KEYWORD,FKEY,IERR)
!  write(8,10)trim(fkey),i
  10 format(' in AJ_GET_INTEGER_BY_KEYWORD, fkey i = ',a,1x,i5)
!  IF (IERR == 0) THEN
    CALL UTL_CASE(FKEY,UPKEY,1)
    SELECT CASE (UPKEY)
      ! Parameters
      CASE ('GPSENMETHOD')
        IF (I > 0 .AND. I .LE. UBOUND(GPSENMETHOD,1)) IVALUE = GPSENMETHOD(I)
      CASE ('GPSOSINCREMENT')
        IF (I > 0 .AND. I .LE. UBOUND(GPSOSINCREMENT,1)) IVALUE = GPSOSINCREMENT(I)
      CASE ('SENMETHOD')
        IF (I > 0 .AND. I .LE. UBOUND(SENMETHOD,1)) IVALUE = SENMETHOD(I)
      CASE ('SOSINCREMENT')
        IF (I > 0 .AND. I .LE. UBOUND(SOSINCREMENT,1)) IVALUE = SOSINCREMENT(I)
      ! Observations
      CASE ('PLOTSYMBOL')
        IF (I > 0 .AND. I .LE. UBOUND(PLOTSYMBOL,1)) IVALUE = PLOTSYMBOL(I)
      ! Predictions
      CASE ('PREDPLOTSYMBOL')
        IF (I > 0 .AND. I .LE. UBOUND(PREDPLOTSYMBOL,1)) IVALUE = PREDPLOTSYMBOL(I)
      ! Prior Information
      CASE ('PRIPLOTSYMBOL')
        IF (I > 0 .AND. I .LE. UBOUND(PRIPLOTSYMBOL,1)) IVALUE = PRIPLOTSYMBOL(I)
      CASE DEFAULT
        IVALUE = -BIGINTEGER
    END SELECT
!  ENDIF
  RETURN
END SUBROUTINE AJ_GET_INTEGER_BY_KEYWORD
!
!###############################################################################
!
SUBROUTINE AJ_GET_LOGICAL_BY_KEYWORD(KEYWORD, INDX, IVALUE);
  !DEC$ ATTRIBUTES DLLEXPORT::AJ_GET_LOGICAL_BY_KEYWORD
  !DEC$ ATTRIBUTES ALIAS:'aj_get_logical_by_keyword' :: AJ_GET_LOGICAL_BY_KEYWORD
  USE GLOBAL_DATA, ONLY: BIGREAL
  USE UTILITIES
  USE DEPENDENTS
  USE UCODE_DATA
  USE AJ_MOD
  IMPLICIT NONE
  CHARACTER(LEN=*), INTENT(INOUT) :: KEYWORD
  INTEGER,          INTENT(INOUT) :: INDX
  INTEGER,          INTENT(INOUT) :: IVALUE
  LOGICAL :: LVALUE
  INTEGER :: I, IERR
  CHARACTER(LEN=256) :: FKEY, UPKEY
  !
  LVALUE = .FALSE.
  I = INDX + 1  ! Convert from 0-based to 1-based indexing
  CALL DSTRING2CHAR(KEYWORD,FKEY,IERR)
!  write(8,10)trim(fkey),i
  10 format(' in AJ_GET_LOGICAL_BY_KEYWORD, fkey i = ',a,1x,i5)
!  IF (IERR == 0) THEN
    CALL UTL_CASE(FKEY,UPKEY,1)
    SELECT CASE (UPKEY)
      CASE ('GPCONSTRAIN')
        IF (I > 0 .AND. I .LE. UBOUND(GPCONSTRAIN,1)) LVALUE = GPCONSTRAIN(I)
      CASE ('GPADJUSTABLE')
        IF (I > 0 .AND. I .LE. UBOUND(GPADJUSTABLE,1)) LVALUE = GPADJUSTABLE(I)
      CASE ('GPTRANSFORM')
        IF (I > 0 .AND. I .LE. UBOUND(GPTRANSFORM,1)) LVALUE = GPTRANSFORM(I)
      CASE ('GPNONLINEARINTERVAL')
        IF (I > 0 .AND. I .LE. UBOUND(GPNONLINEARINT,1)) LVALUE = GPNONLINEARINT(I)
      CASE ('CONSTRAIN')
        IF (I > 0 .AND. I .LE. UBOUND(CONSTRAIN,1)) LVALUE = CONSTRAIN(I)
      CASE ('ADJUSTABLE')
        IF (I > 0 .AND. I .LE. UBOUND(ADJUSTABLE,1)) LVALUE = ADJUSTABLE(I)
      CASE ('TRANSFORM')
        IF (I > 0 .AND. I .LE. UBOUND(TRANSFORM,1)) LVALUE = TRANSFORM(I)
      CASE ('NONLINEARINTERVAL')
        IF (I > 0 .AND. I .LE. UBOUND(NONLINEARINT,1)) LVALUE = NONLINEARINT(I)
      CASE ('GPNONDETECT')
        IF (I > 0 .AND. I .LE. UBOUND(GPNONDETECT,1)) LVALUE = GPNONDETECT(I)
      CASE ('USEFLAG')
        IF (I > 0 .AND. I .LE. UBOUND(USEFLAG,1)) LVALUE = USEFLAG(I)
      CASE ('NONDETECT')
        IF (I > 0 .AND. I .LE. UBOUND(NONDETECT,1)) LVALUE = NONDETECT(I)
      CASE ('PREDUSEFLAG')
        IF (I > 0 .AND. I .LE. UBOUND(PREDUSEFLAG,1)) LVALUE = PREDUSEFLAG(I)
      CASE ('PRIUSEFLAG')
        IF (I > 0 .AND. I .LE. UBOUND(PRIUSEFLAG,1)) LVALUE = PRIUSEFLAG(I)
      CASE DEFAULT
    END SELECT
!  ENDIF
  IVALUE = LOG2INT(LVALUE)
  RETURN
END SUBROUTINE AJ_GET_LOGICAL_BY_KEYWORD
!
!###############################################################################
!
SUBROUTINE AJ_GET_MODEL_COMMAND_BY_PURPOSE(PURP,CMD)
  !DEC$ ATTRIBUTES DLLEXPORT::AJ_GET_MODEL_COMMAND_BY_PURPOSE
  !DEC$ ATTRIBUTES ALIAS:'aj_get_model_command_by_purpose' :: AJ_GET_MODEL_COMMAND_BY_PURPOSE
  !   Return model command line for specified purpose
  USE UTILITIES
  USE BASIC
  USE UCODE_DATA
  USE AJ_MOD
  IMPLICIT NONE
  !   Argument-list variables
  CHARACTER(LEN=*), INTENT(INOUT) :: PURP, CMD
  !   Local variables
  INTEGER :: I, IERR
  CHARACTER(LEN=256) :: CMDLINE, PURPOSE
  !
  CMDLINE = ''
  CALL DSTRING2CHAR(PURP,PURPOSE,IERR)
  FINDPURPOSE: DO I=1,NCOMLINES
    IF (UTL_SAMENAME(COMPURPOSE(I),PURPOSE)) THEN
      CMDLINE = MODCOMLINE(I)
      EXIT FINDPURPOSE
    ENDIF
  ENDDO FINDPURPOSE
  CALL CHAR2DSTRING(CMDLINE,CMD,IERR)
  RETURN
END SUBROUTINE AJ_GET_MODEL_COMMAND_BY_PURPOSE
!
!###############################################################################
!
SUBROUTINE AJ_GET_PARAMETER_GROUP_NAME(INDEX,NAME)
  !DEC$ ATTRIBUTES DLLEXPORT::AJ_GET_PARAMETER_GROUP_NAME
  !DEC$ ATTRIBUTES ALIAS:'aj_get_parameter_group_name' :: AJ_GET_PARAMETER_GROUP_NAME
  USE UCODE_DATA, ONLY: PARGP
  USE AJ_MOD
  IMPLICIT NONE
  INTEGER,          INTENT(INOUT) :: INDEX
  CHARACTER(LEN=*), INTENT(INOUT) :: NAME
  CHARACTER(LEN=13) :: DSTRING
  INTEGER :: I, IERR
  !
  NAME = ''
  I = INDEX + 1  ! Convert from 0-based to 1-based indexing
!  write(8,10)i
  10 format(' in AJ_GET_PARAMETER_GROUP_NAME, i = ',i5)
  IF (I > 0 .AND. I .LE. UBOUND(PARGP,1)) THEN
    CALL CHAR2DSTRING(PARGP(I),DSTRING,IERR)
    IF (IERR == 0) THEN 
      NAME = DSTRING
    ENDIF
  ENDIF
  RETURN
END SUBROUTINE AJ_GET_PARAMETER_GROUP_NAME
!
!###############################################################################
!##############################    AJ_INI    ###################################
!###############################################################################
!
SUBROUTINE AJ_INI(UCODEFILE,IFAIL)
  !DEC$ ATTRIBUTES DLLEXPORT::AJ_INI
  !DEC$ ATTRIBUTES ALIAS:'aj_ini' :: AJ_INI
  !   Initialize AJ (Access Jupiter) module
  USE DATATYPES
  USE GLOBAL_DATA, ONLY: IVERB, MAX_STRING_LEN
  USE BASIC
  USE UCODE_DATA, ONLY: INUNIT, IOUT, MODELNAME, MODELLENGTH, MODELMASS,  &
        MODELTIME, PATHTOMERGEDFILE, UCODEHEAD, GNUCHEAD, TAIL, HEADPARGPS, &
        TAILPARGPS, HEADPARDATA, HEADPARVALDATA, PDHEAD, LLPTRPRED,  &
        LLPTRPREDGP, LLPTRPRI, LLPTRPRIGP
  USE AJ_MOD, ONLY: DSTRING2CHAR
  IMPLICIT NONE
  !   Argument-list variables
  CHARACTER(LEN=*), INTENT(INOUT) :: UCODEFILE
  INTEGER, INTENT(INOUT) :: IFAIL
  !   Local variables
  INTEGER :: IERR, ISTAT
  CHARACTER(LEN=MAX_STRING_LEN) :: UCFILE
  !
  !   Nullify all LLIST pointers.  DO NOT call TYP_NULL.
  NULLIFY(GNUCHEAD)
  NULLIFY(UCODEHEAD)
  NULLIFY(TAIL)
  NULLIFY(HEADPARGPS)
  NULLIFY(TAILPARGPS)
  NULLIFY(HEADPARDATA)
  NULLIFY(HEADPARVALDATA)
  NULLIFY(PDHEAD)
  NULLIFY(LLPTRPRED)
  NULLIFY(LLPTRPREDGP)
  NULLIFY(LLPTRPRI)
  NULLIFY(LLPTRPRIGP)
  !
  !   Initialize variables in JUPITER modules
  IVERB = 5
  DERIV_INTERFACE = ' '
  MODELNAME = ' '
  MODELLENGTH = ' '
  MODELMASS = ' '
  MODELTIME = ' '
  PATHTOMERGEDFILE = ' '
  !
  !   Initialize argument-list and local variables
  IFAIL = 0
  INUNIT = 7
  IOUT = 8
  !
  open(unit=iout,file='AJ_output.txt',status='REPLACE')
  CALL DSTRING2CHAR(UCODEFILE,UCFILE,IERR)
  IF (IERR == 0) THEN
    OPEN(UNIT=INUNIT,FILE=UCFILE,STATUS='OLD',IOSTAT=ISTAT)
    IF (ISTAT.NE.0) THEN
      WRITE(IOUT,50)TRIM(UCFILE)
      50 FORMAT(1X,'Cannot open file: ',A)
    ENDIF
    IFAIL = ISTAT
  ELSE
    IFAIL = IERR
  ENDIF
  RETURN
END SUBROUTINE AJ_INI
!
!###############################################################################
!
SUBROUTINE AJ_BAS_INI_GETOPTIONS(IVB,DERIV_INT,PATH2MERGEDFILE,IFAIL)
  !DEC$ ATTRIBUTES DLLEXPORT::AJ_BAS_INI_GETOPTIONS
  !DEC$ ATTRIBUTES ALIAS:'aj_bas_ini_getoptions' :: AJ_BAS_INI_GETOPTIONS
  !   Read OPTIONS input block
  USE UCODE_DATA, ONLY: INUNIT, IOUT, PATHTOMERGEDFILE
  USE GLOBAL_DATA, ONLY: IVERB
  USE BASIC
  USE UTILITIES
  USE AJ_MOD, ONLY: CHAR2DSTRING
  IMPLICIT NONE
  !   Argument-list variables
  INTEGER, INTENT(INOUT)          :: IVB        ! IVERB
  CHARACTER(LEN=*), INTENT(INOUT) :: DERIV_INT  ! DERIVATIVES_INTERFACE
  CHARACTER(LEN=*), INTENT(INOUT) :: PATH2MERGEDFILE ! PathToMergedFile
  INTEGER, INTENT(INOUT)          :: IFAIL
  !   Local variables
  INTEGER :: IERR
  !
  IFAIL = 0
  CALL BAS_INI_GETOPTIONS(INUNIT,IOUT)
  IVB = IVERB
  CALL CHAR2DSTRING(DERIV_INTERFACE,DERIV_INT,IERR)
  IF (IERR.NE.0) IFAIL = IERR
  CALL UTL_FILTER(IERR,LLPTROPT,IOUT,'PATHTOMERGEDFILE',PATHTOMERGEDFILE)
  IF (IERR.NE.0) IFAIL = IERR
  CALL CHAR2DSTRING(PATHTOMERGEDFILE,PATH2MERGEDFILE,IERR)
  IF (IERR.NE.0) IFAIL = IERR
  RETURN
END SUBROUTINE AJ_BAS_INI_GETOPTIONS
!
!###############################################################################
!
SUBROUTINE AJ_INI_UCODE_CONTROL_DATA(PRED,OPTIMIZ,SENS,LIN,NONLININT,STDERR1,  &
               WRITEDERPARS,WRITEPRIINFO,EIGENVAL,DATAEX,CRINITFILES,   &
               LINADV,MODNAME,MODLENUNIT,MODMASSUNIT,MODTIMEUNIT,SOSSURF,  &
               SOSFIL,STRTRES,INTRES,FINRES,STRTSENS,INTSENS,FINSENS,  &
               IFAIL,DERRMSG)
  !DEC$ ATTRIBUTES DLLEXPORT::AJ_INI_UCODE_CONTROL_DATA
  !DEC$ ATTRIBUTES ALIAS:'aj_ini_ucode_control_data' :: AJ_INI_UCODE_CONTROL_DATA
  USE UCODE_DATA
  USE AJ_MOD
  USE GLOBAL_DATA, ONLY: GERR, IVERB, ERRMESSAGE
  USE UTILITIES
  IMPLICIT NONE
  !   Argument-list variables
  INTEGER, INTENT(INOUT) :: PRED, OPTIMIZ, SENS, LIN, NONLININT, STDERR1,  &
        WRITEDERPARS, WRITEPRIINFO, EIGENVAL, DATAEX, CRINITFILES
  CHARACTER(LEN=*), INTENT(INOUT) :: LINADV, MODNAME, MODLENUNIT, MODMASSUNIT, &
        MODTIMEUNIT, SOSSURF, SOSFIL, STRTRES, INTRES, FINRES, STRTSENS,  &
        INTSENS, FINSENS
  INTEGER, INTENT(INOUT)          :: IFAIL
  CHARACTER(LEN=*), INTENT(INOUT) :: DERRMSG
  !   Local variables, with defaults
  CHARACTER(LEN=40), DIMENSION(1) :: UCODECOL = (/ '      '/)
  CHARACTER(LEN=79) :: STARTRESC = 'yes'
  CHARACTER(LEN=79) :: INTERMEDRESC = 'no'
  CHARACTER(LEN=79) :: FINALRESC = 'yes'
  CHARACTER(LEN=79) :: STARTSENSC = 'dss'
  CHARACTER(LEN=79) :: INTERMEDSENSC = 'none '
  CHARACTER(LEN=79) :: FINALSENSC = 'dss '
  LOGICAL           :: WRITEDERIVEDPARAMS = .TRUE.
  LOGICAL           :: WRITEPRIORINFO = .TRUE.
  LOGICAL           :: EIGENVALUES = .TRUE.
  INTEGER :: IERR, NUCODE
  !
  STDERRONE = .FALSE.
  GERR = .FALSE.
  IFAIL = 0
  NUCODE = 0
  !
  !   Assign defaults
  !   Integer arguments that represent logical/boolean values, where 0=false and 1=true
  PRED = 0          ! Default = False
  OPTIMIZ = 0       ! Default = False
  SENS = 0          ! Default = False
  LIN = 0           ! Default = False
  NONLININT = 0     ! Default = False
  STDERR1 = 0       ! Default = False
  WRITEDERPARS = 1  ! Default = True
  WRITEPRIINFO = 1  ! Default = True
  EIGENVAL = 1      ! Default = True
  DATAEX = 1        ! Default = True
  CRINITFILES = 0   ! Default = False
  CALL CHAR2DSTRING('no',LINADV,IERR)
  CALL CHAR2DSTRING(' ',MODNAME,IERR)
  IF (IERR.NE.0) THEN
    WRITE(IOUT,*)' CALL CHAR2DSTRING fails in AJ_INI_UCODE_CONTROL_DATA'
    CALL UTL_STOP()
  ENDIF
  CALL CHAR2DSTRING(' ',MODLENUNIT,IERR)
  CALL CHAR2DSTRING(' ',MODMASSUNIT,IERR)
  CALL CHAR2DSTRING(' ',MODTIMEUNIT,IERR)
  !
  CALL UTL_READBLOCK(0,'UCODE_CONTROL_DATA',UCODECOL,INUNIT,IOUT,  &
                     '*',.FALSE.,UCODEHEAD,TAIL,NUCODE)
  IF (IVERB>4) CALL UTL_WRITEBLOCK(UCODEHEAD,IOUT)
  IF (NUCODE>0) THEN
    CALL UTL_FILTER(IERR,UCODEHEAD,IOUT,'PREDICTION',PREDICTION)
    IF (GERR) GOTO 900
    PRED = LOG2INT(PREDICTION)
    CALL UTL_FILTER(IERR,UCODEHEAD,IOUT,'OPTIMIZE',OPTIMIZE)
    IF (GERR) GOTO 900
    OPTIMIZ = LOG2INT(OPTIMIZE)
    CALL UTL_FILTER(IERR,UCODEHEAD,IOUT,'NONLINEARINTERVALS',OPTNLUNC)
    IF (GERR) GOTO 900
    NONLININT = LOG2INT(OPTNLUNC)
    CALL UTL_FILTER(IERR,UCODEHEAD,IOUT,'STDERRONE',STDERRONE)
    IF (GERR) GOTO 900
    STDERR1 = LOG2INT(STDERRONE)
    CALL UTL_FILTER(IERR,UCODEHEAD,IOUT,'MODELNAME',MODELNAME)
    IF (GERR) GOTO 900
    CALL CHAR2DSTRING(MODELNAME,MODNAME,IERR)
    CALL UTL_FILTER(IERR,UCODEHEAD,IOUT,'MODELLENGTHUNITS',MODELLENGTH)
    IF (GERR) GOTO 900
    CALL CHAR2DSTRING(MODELLENGTH,MODLENUNIT,IERR)
    CALL UTL_FILTER(IERR,UCODEHEAD,IOUT,'MODELMASSUNITS',MODELMASS)
    IF (GERR) GOTO 900
    CALL CHAR2DSTRING(MODELMASS,MODMASSUNIT,IERR)
    CALL UTL_FILTER(IERR,UCODEHEAD,IOUT,'MODELTIMEUNITS',MODELTIME)
    IF (GERR) GOTO 900
    CALL CHAR2DSTRING(MODELTIME,MODTIMEUNIT,IERR)
    CALL UTL_FILTER(IERR,UCODEHEAD,IOUT,'SOSFILE',SOSFILE)
    IF (GERR) GOTO 900
    CALL CHAR2DSTRING(SOSFILE,SOSFIL,IERR)
    CALL UTL_FILTER(IERR,UCODEHEAD,IOUT,'SOSSURFACE',SOSSURFACEINPUT)
    IF (GERR) GOTO 900
    CALL CHAR2DSTRING(SOSSURFACEINPUT,SOSSURF,IERR)
    CALL UTL_FILTER(IERR,UCODEHEAD,IOUT,'SENSITIVITIES',SENSITIVITIES)
    SENS = LOG2INT(SENSITIVITIES)
    CALL UTL_FILTER(IERR,UCODEHEAD,IOUT,'CREATEINITFILES', CREATEINITFILES)
    IF (GERR) GOTO 900
    CRINITFILES = LOG2INT(CREATEINITFILES)
    CALL UTL_FILTER(IERR,UCODEHEAD,IOUT,'LINEARITY',LINEARITY)
    IF (GERR) GOTO 900
    LIN = LOG2INT(LINEARITY)
    CALL UTL_FILTER(IERR,UCODEHEAD,IOUT,'LINEARITYADV',LINADVANS)
    IF (GERR) GOTO 900
    CALL CHAR2DSTRING(LINADVANS,LINADV,IERR)
    CALL UTL_FILTER(IERR,UCODEHEAD,IOUT,'STARTRES',STARTRESC)
    IF (GERR) GOTO 900
    CALL CHAR2DSTRING(STARTRESC,STRTRES,IERR)
    CALL UTL_FILTER(IERR,UCODEHEAD,IOUT,'INTERMEDRES',INTERMEDRESC)
    IF (GERR) GOTO 900
    CALL CHAR2DSTRING(INTERMEDRESC,INTRES,IERR)
    CALL UTL_FILTER(IERR,UCODEHEAD,IOUT,'FINALRES',FINALRESC)
    IF (GERR) GOTO 900
    CALL CHAR2DSTRING(FINALRESC,FINRES,IERR)
    CALL UTL_FILTER(IERR,UCODEHEAD,IOUT,'STARTSENS',STARTSENSC)
    IF (GERR) GOTO 900
    CALL CHAR2DSTRING(STARTSENSC,STRTSENS,IERR)
    CALL UTL_FILTER(IERR,UCODEHEAD,IOUT,'INTERMEDSENS',INTERMEDSENSC)
    IF (GERR) GOTO 900
    CALL CHAR2DSTRING(INTERMEDSENSC,INTSENS,IERR)
    CALL UTL_FILTER(IERR,UCODEHEAD,IOUT,'FINALSENS',FINALSENSC)
    IF (GERR) GOTO 900
    CALL CHAR2DSTRING(FINALSENSC,FINSENS,IERR)
    CALL UTL_FILTER(IERR,UCODEHEAD,IOUT,'DATAEXCHANGE',DATAEXCHANGE)
    IF (GERR) GOTO 900
    DATAEX = LOG2INT(DATAEXCHANGE)
    CALL UTL_FILTER(IERR,UCODEHEAD,IOUT,'WRITEDERIVEDPARAMS',WRITEDERIVEDPARAMS)
    IF (GERR) GOTO 900
    WRITEDERPARS = LOG2INT(WRITEDERIVEDPARAMS)
    CALL UTL_FILTER(IERR,UCODEHEAD,IOUT,'WRITEPRIORINFO',WRITEPRIORINFO)
    IF (GERR) GOTO 900
    WRITEPRIINFO = LOG2INT(WRITEPRIORINFO)
    CALL UTL_FILTER(IERR,UCODEHEAD,IOUT,'EIGENVALUES',EIGENVALUES)
    IF (GERR) GOTO 900
    EIGENVAL = LOG2INT(EIGENVALUES)
    !
    IF (PREDICTION) THEN
      PREDICT = .TRUE.
!      PRED_MODADV = .TRUE.
    ENDIF
  ENDIF
  900 CONTINUE
  IF (GERR) THEN
    WRITE(IOUT,910)TRIM(ERRMESSAGE)
    910 FORMAT('Error in AJ_INI_UCODE_CONTROL_DATA: ',a)
    CALL CHAR2DSTRING(ERRMESSAGE,DERRMSG,IERR)
    IFAIL = 1
  ENDIF
  RETURN
END SUBROUTINE AJ_INI_UCODE_CONTROL_DATA
!
!###############################################################################
!
SUBROUTINE AJ_INI_REG_GN_CONTROLS(MAXIT,LQN,IQNITER,IOMITDEF,LSTATSONNC,   &
      LOMITINSENS,ICONSECMAX,DTOLPAR,DTOLSOSC,DMAXCHG,DMQRTDIR,DMQRTFAC,   &
      DMQRTINC,DQNSOSR,DMINSENRAT,DREINCSENRAT,DTOLPARWTOS,DMAXSTEP,   &
      CMAXCHGREALM,CTRUSTREG,IFAIL)
  !DEC$ ATTRIBUTES DLLEXPORT::AJ_INI_REG_GN_CONTROLS
  !DEC$ ATTRIBUTES ALIAS:'aj_ini_reg_gn_controls' :: AJ_INI_REG_GN_CONTROLS
  USE UTILITIES
  USE UCODE_DATA
  USE AJ_MOD
  USE GLOBAL_DATA, ONLY: IVERB
  IMPLICIT NONE
  !
  !   Argument-list variables
  INTEGER, INTENT(INOUT) :: MAXIT, LQN, IQNITER, IOMITDEF, LSTATSONNC,   &
      LOMITINSENS, ICONSECMAX, IFAIL
  DOUBLE PRECISION, INTENT(INOUT) :: DTOLPAR, DTOLSOSC, DMAXCHG, DMQRTDIR,   &
      DMQRTFAC, DMQRTINC, DQNSOSR, DMINSENRAT, DREINCSENRAT, DTOLPARWTOS,   &
      DMAXSTEP
  CHARACTER(LEN=*), INTENT(INOUT) :: CMAXCHGREALM, CTRUSTREG
  !
  !   Local variables
  INTEGER :: IERR, NGNUC
  CHARACTER(LEN=40), DIMENSION(1) :: GNUCCOL = (/ '      '/)
  CHARACTER(LEN=12) :: TREG, MCREALM
  LOGICAL :: QN, SON, OI
  integer :: itmp1, itmp2
  !
  !   Assign defaults
  itmp1 = ichar(CMAXCHGREALM(1:1))
  itmp2 = ichar(CTRUSTREG(1:1))
  MAXIT = 5
  LQN = 0  ! false
  IQNITER = 5
  IOMITDEF = 0
  LSTATSONNC = 1 ! true
  LOMITINSENS = 0 ! false
  ICONSECMAX = 5
  DTOLPAR = 0.01D0
  DTOLSOSC = 0.0D0
  DMAXCHG = 2.0D0
  DMQRTDIR = 85.4D0
  DMQRTFAC = 1.5D0
  DMQRTINC = 0.001D0
  DQNSOSR = 0.01D0
  DMINSENRAT = 0.005D0
  DREINCSENRAT = 0.02D0
  DTOLPARWTOS = 10.0D0
  DMAXSTEP = 0.0D0
  IERR = 0
  MCREALM = 'Native'
  TREG = 'no'
  NGNUC = 0
  CALL CHAR2DSTRING(MCREALM,CMAXCHGREALM,IERR)
  CALL CHAR2DSTRING(TREG,CTRUSTREG,IERR)
  !  
  CALL UTL_READBLOCK(0,'REG_GN_CONTROLS',GNUCCOL,INUNIT,IOUT,  &
                     '*',.FALSE.,GNUCHEAD,TAIL,NGNUC)
  IF (IVERB>4) CALL UTL_WRITEBLOCK(GNUCHEAD,IOUT)
  IF (NGNUC>0) THEN
    CALL UTL_FILTER(IERR,GNUCHEAD,IOUT,'TOLPAR',DTOLPAR)
    CALL UTL_FILTER(IERR,GNUCHEAD,IOUT,'TOLSOSC',DTOLSOSC)
    CALL UTL_FILTER(IERR,GNUCHEAD,IOUT,'MAXITER',MAXIT)
    CALL UTL_FILTER(IERR,GNUCHEAD,IOUT,'MAXCHANGE',DMAXCHG)
    CALL UTL_FILTER(IERR,GNUCHEAD,IOUT,'MAXCHANGEREALM',MCREALM)
    CALL CHAR2DSTRING(MCREALM,CMAXCHGREALM,IERR)
    CALL UTL_FILTER(IERR,GNUCHEAD,IOUT,'MQRTDIRECTION',DMQRTDIR)
    CALL UTL_FILTER(IERR,GNUCHEAD,IOUT,'MQRTFACTOR',DMQRTFAC)
    CALL UTL_FILTER(IERR,GNUCHEAD,IOUT,'MQRTINCREMENT',DMQRTINC)
    CALL UTL_FILTER(IERR,GNUCHEAD,IOUT,'QUASINEWTON',QN)
    LQN = LOG2INT(QN)
    CALL UTL_FILTER(IERR,GNUCHEAD,IOUT,'QNITER',IQNITER)
    CALL UTL_FILTER(IERR,GNUCHEAD,IOUT,'QNSOSR',DQNSOSR)
    CALL UTL_FILTER(IERR,GNUCHEAD,IOUT,'OMITDEFAULT',IOMITDEF)
    CALL UTL_FILTER(IERR,GNUCHEAD,IOUT,'STATS_ON_NONCONVERGE',SON)
    LSTATSONNC = LOG2INT(SON)
    CALL UTL_FILTER(IERR,GNUCHEAD,IOUT,'OMITINSENSITIVE',OI)
    LOMITINSENS = LOG2INT(OI)
    CALL UTL_FILTER(IERR,GNUCHEAD,IOUT,'MINIMUMSENSRATIO',DMINSENRAT)
    CALL UTL_FILTER(IERR,GNUCHEAD,IOUT,'REINCLUDESENSRATIO',DREINCSENRAT)
    CALL UTL_FILTER(IERR,GNUCHEAD,IOUT,'TOLPARWTOS',DTOLPARWTOS)
    CALL UTL_FILTER(IERR,GNUCHEAD,IOUT,'TRUSTREGION',TREG)
    CALL CHAR2DSTRING(TREG,CTRUSTREG,IERR)
    CALL UTL_FILTER(IERR,GNUCHEAD,IOUT,'MAXSTEP',DMAXSTEP)
    CALL UTL_FILTER(IERR,GNUCHEAD,IOUT,'CONSECMAX',ICONSECMAX)
  ENDIF
  RETURN
END SUBROUTINE AJ_INI_REG_GN_CONTROLS
!
!###############################################################################
!
SUBROUTINE AJ_INI_MODEL_COMMAND_LINES(NCOMMANDS)
  !DEC$ ATTRIBUTES DLLEXPORT::AJ_INI_MODEL_COMMAND_LINES
  !DEC$ ATTRIBUTES ALIAS:'aj_ini_model_command_lines' :: AJ_INI_MODEL_COMMAND_LINES
  USE UTILITIES
  USE BASIC
  USE UCODE_DATA, ONLY : INUNIT, IOUT
  IMPLICIT NONE
  !   Argument-list variables
  INTEGER, INTENT(INOUT) :: NCOMMANDS
  !
  NCOMMANDS = 0
  CALL BAS_INI_MODELEXEC(INUNIT,IOUT)
  NCOMMANDS = NCOMLINES
  RETURN
END SUBROUTINE AJ_INI_MODEL_COMMAND_LINES
!
!###############################################################################
!
SUBROUTINE AJ_INI_PARAMETER_GROUPS(NPARGPS)
  !DEC$ ATTRIBUTES DLLEXPORT::AJ_INI_PARAMETER_GROUPS
  !DEC$ ATTRIBUTES ALIAS:'aj_ini_parameter_groups' :: AJ_INI_PARAMETER_GROUPS
  ! Read a Parameter_Groups input block, if present
  USE GLOBAL_DATA, ONLY: IVERB, BIGREAL
  USE DATATYPES
  USE UTILITIES
  USE UCODE_DATA, ONLY: INUNIT, IOUT, HEADPARGPS, TAILPARGPS, PARGP, &
          GPLOWERVALUE, GPUPPERVALUE, &
          GPLOWERCONSTRAINT, GPUPPERCONSTRAINT, GPPERTURBAMT, GPTOLPAR, &
          GPMAXCHANGE, GPSCALEPVAL, GPCONSTRAIN, GPADJUSTABLE, &
          GPTRANSFORM, GPNONLINEARINT, &
          GPSENMETHOD, GPSOSINCREMENT  
  IMPLICIT NONE
  !   Argument-list variables
  INTEGER, INTENT(INOUT) :: NPARGPS
  !
  !   Local variables
  INTEGER, PARAMETER :: NDEFCOLS = 0
  CHARACTER(LEN=16)  :: BLABEL = 'PARAMETER_GROUPS'      ! Block label
  CHARACTER(LEN=40), DIMENSION(NDEFCOLS) :: COLNAMES
  CHARACTER(LEN=9)   :: KITEM = 'GROUPNAME'       ! Key item
  LOGICAL            :: REQUIRED = .FALSE.
  INTEGER :: IERR, MORE
      
  !
  NPARGPS = 0
  CALL UTL_READBLOCK(NDEFCOLS,BLABEL,COLNAMES,INUNIT,IOUT,  &
                     KITEM,REQUIRED,HEADPARGPS,TAILPARGPS,NPARGPS)
  IF (IVERB>4) CALL UTL_WRITEBLOCK(HEADPARGPS,IOUT)
  IF (NPARGPS > 0) THEN
    ALLOCATE(PARGP(NPARGPS))
    CALL UTL_FILTERLIST(HEADPARGPS, IOUT, 'GROUPNAME', NPARGPS, IERR, PARGP, MORE)
    ALLOCATE(GPLOWERVALUE(NPARGPS), GPUPPERVALUE(NPARGPS), &
        GPLOWERCONSTRAINT(NPARGPS), GPUPPERCONSTRAINT(NPARGPS), &
        GPPERTURBAMT(NPARGPS), GPTOLPAR(NPARGPS), &
        GPMAXCHANGE(NPARGPS), GPSCALEPVAL(NPARGPS), &
        GPCONSTRAIN(NPARGPS), GPADJUSTABLE(NPARGPS), &
        GPTRANSFORM(NPARGPS), GPNONLINEARINT(NPARGPS), &
        GPSENMETHOD(NPARGPS), GPSOSINCREMENT(NPARGPS))
    !   Assign default attribute values
    GPLOWERVALUE = -10.0D38
    GPUPPERVALUE = 10.0D38
    GPCONSTRAIN = .FALSE.
    GPLOWERCONSTRAINT = -10.0D38
    GPUPPERCONSTRAINT = 10.0D38
    GPADJUSTABLE = .FALSE.
    GPPERTURBAMT = 0.01D0
    GPTRANSFORM = .FALSE.
    GPTOLPAR = 0.01D0
    GPMAXCHANGE = 2.0D0
    GPSENMETHOD = 1
    GPSCALEPVAL = 10.0D38
    GPSOSINCREMENT = 5
    GPNONLINEARINT = .FALSE.
    !   Populate arrays with data from input block
    CALL UTL_FILTERLIST(HEADPARGPS, IOUT, 'LOWERVALUE', NPARGPS, IERR, GPLOWERVALUE, MORE)
    CALL UTL_FILTERLIST(HEADPARGPS, IOUT, 'UPPERVALUE', NPARGPS, IERR, GPUPPERVALUE, MORE)
    CALL UTL_FILTERLIST(HEADPARGPS, IOUT, 'CONSTRAIN', NPARGPS, IERR, GPCONSTRAIN, MORE)
    CALL UTL_FILTERLIST(HEADPARGPS, IOUT, 'LOWERCONSTRAINT', NPARGPS, IERR, GPLOWERCONSTRAINT, MORE)
    CALL UTL_FILTERLIST(HEADPARGPS, IOUT, 'UPPERCONSTRAINT', NPARGPS, IERR, GPUPPERCONSTRAINT, MORE)
    CALL UTL_FILTERLIST(HEADPARGPS, IOUT, 'ADJUSTABLE', NPARGPS, IERR, GPADJUSTABLE, MORE)
    CALL UTL_FILTERLIST(HEADPARGPS, IOUT, 'PERTURBAMT', NPARGPS, IERR, GPPERTURBAMT, MORE)
    CALL UTL_FILTERLIST(HEADPARGPS, IOUT, 'TRANSFORM', NPARGPS, IERR, GPTRANSFORM, MORE)
    CALL UTL_FILTERLIST(HEADPARGPS, IOUT, 'TOLPAR', NPARGPS, IERR, GPTOLPAR, MORE)
    CALL UTL_FILTERLIST(HEADPARGPS, IOUT, 'MAXCHANGE', NPARGPS, IERR, GPMAXCHANGE, MORE)
    CALL UTL_FILTERLIST(HEADPARGPS, IOUT, 'SENMETHOD', NPARGPS, IERR, GPSENMETHOD, MORE)
    CALL UTL_FILTERLIST(HEADPARGPS, IOUT, 'SCALEPVAL', NPARGPS, IERR, GPSCALEPVAL, MORE)
    CALL UTL_FILTERLIST(HEADPARGPS, IOUT, 'SOSINCREMENT', NPARGPS, IERR, GPSOSINCREMENT, MORE)
    CALL UTL_FILTERLIST(HEADPARGPS, IOUT, 'NONLINEARINTERVAL', NPARGPS, IERR, GPNONLINEARINT, MORE)
  ENDIF                   
END SUBROUTINE AJ_INI_PARAMETER_GROUPS
!
!###############################################################################
!
SUBROUTINE AJ_INI_PARAMETER_DATA(NPARS)
  !DEC$ ATTRIBUTES DLLEXPORT::AJ_INI_PARAMETER_DATA
  !DEC$ ATTRIBUTES ALIAS:'aj_ini_parameter_data' :: AJ_INI_PARAMETER_DATA
  ! Read a Parameter_Data input block, if present
  USE GLOBAL_DATA, ONLY: IVERB, BIGREAL
  USE DATATYPES
  USE UTILITIES
  USE UCODE_DATA, ONLY: INUNIT, IOUT, HEADPARDATA, TAIL, &
          LOWERVALUE, UPPERVALUE, &
          LOWERCONSTRAINT, UPPERCONSTRAINT, PERTURBAMT, TOLPAR, &
          MAXCHANGE, SCALEPVAL, PARNAM, GROUPNAME, STARTVALUE , &
          HEADPARDATA, GROUPNAME, CONSTRAIN, ADJUSTABLE, TRANSFORM, &
          NONLINEARINT, SENMETHOD, SOSINCREMENT, NPARCOLS, PARCOL, &
          HEADPARVALDATA, NPDCOLS, PDCOL, PDHEAD, NPVCOLS, PVCOL
  IMPLICIT NONE
  !   Argument-list variables
  INTEGER, INTENT(INOUT) :: NPARS
  !
  !   Local variables
  CHARACTER(LEN=16)  :: BLABEL  ! Block label
  CHARACTER(LEN=9)   :: KITEM = 'PARAMNAME'       ! Key item
  LOGICAL            :: REQUIRED = .FALSE.
  INTEGER :: IERR, MORE, NPD, NPV
  !
  NPARS = 0
  BLABEL = 'PARAMETER_DATA'
  CALL UTL_READBLOCK(NPARCOLS,BLABEL,PARCOL,INUNIT,IOUT,  &
                     KITEM,REQUIRED,HEADPARDATA,TAIL,NPARS)
  IF (IVERB>4) CALL UTL_WRITEBLOCK(HEADPARDATA,IOUT)
  IF (NPARS > 0) THEN
    ALLOCATE(PARNAM(NPARS))
    CALL UTL_FILTERLIST(HEADPARDATA, IOUT, 'PARAMNAME', NPARS, IERR, PARNAM, MORE)
    ALLOCATE(GROUPNAME(NPARS), LOWERVALUE(NPARS), UPPERVALUE(NPARS), &
        LOWERCONSTRAINT(NPARS), UPPERCONSTRAINT(NPARS), &
        PERTURBAMT(NPARS), TOLPAR(NPARS), &
        MAXCHANGE(NPARS), SCALEPVAL(NPARS), STARTVALUE(NPARS), &
        CONSTRAIN(NPARS), ADJUSTABLE(NPARS), TRANSFORM(NPARS), &
        NONLINEARINT(NPARS), SENMETHOD(NPARS), SOSINCREMENT(NPARS))
    !   Assign default values
    GROUPNAME = 'ParamDefault'
    STARTVALUE = 10.0D38
    LOWERVALUE = -10.0D38
    UPPERVALUE = 10.0D38
    CONSTRAIN = .FALSE.
    LOWERCONSTRAINT = -10.0D38
    UPPERCONSTRAINT = 10.0D38
    ADJUSTABLE = .FALSE.
    PERTURBAMT = 0.01D0
    TRANSFORM = .FALSE.
    TOLPAR = 0.01D0
    MAXCHANGE = 2.0D0
    SENMETHOD = 1
    SCALEPVAL = 10.0D38
    SOSINCREMENT = 5
    NONLINEARINT = .FALSE.
    !
    !   Look for Parameter_Values block 
    NPV = 0
    BLABEL = 'PARAMETER_VALUES'
    REQUIRED = .FALSE.
    CALL UTL_READBLOCK(NPVCOLS,BLABEL,PVCOL,INUNIT,IOUT,  &
                       KITEM,REQUIRED,HEADPARVALDATA,TAIL,NPV)
    IF (NPV>0) THEN
      IF (IVERB>4) CALL UTL_WRITEBLOCK(HEADPARVALDATA,IOUT)
      !   Merge PARAMETER_VALUES data with PARAMETER_DATA data
      CALL UTL_MERGELIST('PARAMETER_DATA','PARAMETER_VALUES',HEADPARDATA,HEADPARVALDATA,IOUT)
      IF (IVERB>4) THEN
        !   Write block information (parameters) to output file
        WRITE(IOUT,'(/,A)')'Echo parameter input after merging with parameter-values block:'
        CALL UTL_WRITEBLOCK(HEADPARDATA,IOUT)
        WRITE(IOUT,'(/,A)')'After CALL UTL_WRITEBLOCK(HEADPARDATA,IOUT)'
      ENDIF
    ENDIF
    !
    !   Populate arrays with data from input blocks
    CALL UTL_FILTERLIST(HEADPARDATA, IOUT, 'GROUPNAME', NPARS, IERR, GROUPNAME, MORE)
    CALL UTL_FILTERLIST(HEADPARDATA, IOUT, 'STARTVALUE', NPARS, IERR, STARTVALUE, MORE)
    CALL UTL_FILTERLIST(HEADPARDATA, IOUT, 'LOWERVALUE', NPARS, IERR, LOWERVALUE, MORE)
    CALL UTL_FILTERLIST(HEADPARDATA, IOUT, 'UPPERVALUE', NPARS, IERR, UPPERVALUE, MORE)
    CALL UTL_FILTERLIST(HEADPARDATA, IOUT, 'CONSTRAIN', NPARS, IERR, CONSTRAIN, MORE)
    CALL UTL_FILTERLIST(HEADPARDATA, IOUT, 'LOWERCONSTRAINT', NPARS, IERR, LOWERCONSTRAINT, MORE)
    CALL UTL_FILTERLIST(HEADPARDATA, IOUT, 'UPPERCONSTRAINT', NPARS, IERR, UPPERCONSTRAINT, MORE)
    CALL UTL_FILTERLIST(HEADPARDATA, IOUT, 'ADJUSTABLE', NPARS, IERR, ADJUSTABLE, MORE)
    CALL UTL_FILTERLIST(HEADPARDATA, IOUT, 'PERTURBAMT', NPARS, IERR, PERTURBAMT, MORE)
    CALL UTL_FILTERLIST(HEADPARDATA, IOUT, 'TRANSFORM', NPARS, IERR, TRANSFORM, MORE) 
    CALL UTL_FILTERLIST(HEADPARDATA, IOUT, 'TOLPAR', NPARS, IERR, TOLPAR, MORE)
    CALL UTL_FILTERLIST(HEADPARDATA, IOUT, 'MAXCHANGE', NPARS, IERR, MAXCHANGE, MORE)
    CALL UTL_FILTERLIST(HEADPARDATA, IOUT, 'SENMETHOD', NPARS, IERR, SENMETHOD, MORE)
    CALL UTL_FILTERLIST(HEADPARDATA, IOUT, 'SCALEPVAL', NPARS, IERR, SCALEPVAL, MORE)
    CALL UTL_FILTERLIST(HEADPARDATA, IOUT, 'NONLINEARINTERVAL', NPARS, IERR, NONLINEARINT, MORE)
    CALL UTL_FILTERLIST(HEADPARDATA, IOUT, 'SCALEPVAL', NPARS, IERR, SCALEPVAL, MORE)
  ENDIF
END SUBROUTINE AJ_INI_PARAMETER_DATA
!
!###############################################################################
!
SUBROUTINE AJ_INI_DERIVED_PARAMETERS(NPD)
  !DEC$ ATTRIBUTES DLLEXPORT::AJ_INI_DERIVED_PARAMETERS
  !DEC$ ATTRIBUTES ALIAS:'aj_ini_derived_parameters' :: AJ_INI_DERIVED_PARAMETERS
  ! Read a Parameter_Groups input block, if present
  USE GLOBAL_DATA, ONLY: IVERB, BIGREAL
  USE DATATYPES
  USE UTILITIES
  USE UCODE_DATA, ONLY: NPDCOLS, PDCOL, INUNIT, IOUT, PDHEAD, TAIL, &
                        DERPARNAME, DERPAREQN
  IMPLICIT NONE
  INTEGER, INTENT(INOUT) :: NPD
  INTEGER :: IERR, MORE
  !   Read and store information in DERIVED_PARAMETERS block
  NPD = 0
  CALL UTL_READBLOCK(NPDCOLS,'DERIVED_PARAMETERS',PDCOL,INUNIT,IOUT,   &
      'DERPARNAME',.FALSE.,PDHEAD,TAIL,NPD)
  IF (IVERB>4 .AND. NPD>0) THEN
    !   Write block information (derived parameters) to output file
    WRITE(IOUT,'(/,A)')'Echo derived parameters block:'
    CALL UTL_WRITEBLOCK(PDHEAD,IOUT)
  ENDIF 
  IF (NPD>0) THEN
    ALLOCATE(DERPARNAME(NPD), DERPAREQN(NPD))
    DERPARNAME = ''
    DERPAREQN = ''
    CALL UTL_FILTERLIST(PDHEAD,IOUT,'DERPARNAME',NPD,IERR,DERPARNAME,MORE)
    CALL UTL_FILTERLIST(PDHEAD,IOUT,'DERPAREQN',NPD,IERR,DERPAREQN,MORE)
  ENDIF
  RETURN
END SUBROUTINE AJ_INI_DERIVED_PARAMETERS
!
!###############################################################################
!
SUBROUTINE AJ_INI_OBSERVATION_GROUPS(NOBGP)
  !DEC$ ATTRIBUTES DLLEXPORT::AJ_INI_OBSERVATION_GROUPS
  !DEC$ ATTRIBUTES ALIAS:'aj_ini_observation_groups' :: AJ_INI_OBSERVATION_GROUPS
  ! Read Observation_Groups input block, if present
  USE GLOBAL_DATA, ONLY: IVERB, BIGREAL
  USE DATATYPES
  USE UTILITIES
  USE DEPENDENTS, ONLY: DEP_INI_READ, GROUPNAM, LLPTRDEPGP, NOBSGPS, &
                        PLOTSYMBOL, USEFLAG, WTMULTIPLIER, COVMATNAM
  USE UCODE_DATA, ONLY: INUNIT, IOUT, TAIL, GPSTATISTIC, GPSTATFLAG, &
                        GPNONDETECT, GPWTOSCONSTANT
  IMPLICIT NONE
  !   Argument-list variables
  INTEGER, INTENT(INOUT) :: NOBGP
  !
  !   Local variables
  INTEGER, PARAMETER :: NDEFCOLS = 0
  CHARACTER(LEN=20)  :: BLABEL = 'OBSERVATION_GROUPS'      ! Block label
  CHARACTER(LEN=40), DIMENSION(NDEFCOLS) :: COLNAMES
  CHARACTER(LEN=9)   :: KITEM = 'GROUPNAME'       ! Key item
  LOGICAL            :: REQUIRED = .FALSE.
  INTEGER :: IERR, MORE
      
  !
  NOBSGPS = 0
  CALL UTL_READBLOCK(NDEFCOLS,BLABEL,COLNAMES,INUNIT,IOUT,  &
                     KITEM,REQUIRED,LLPTRDEPGP,TAIL,NOBSGPS)
  NOBGP = NOBSGPS
  IF (IVERB>4) CALL UTL_WRITEBLOCK(LLPTRDEPGP,IOUT)
  IF (NOBSGPS > 0) THEN
    ALLOCATE(GROUPNAM(NOBSGPS))
    CALL UTL_FILTERLIST(LLPTRDEPGP, IOUT, 'GROUPNAME', NOBSGPS, IERR, GROUPNAM, MORE)
    ALLOCATE(USEFLAG(NOBSGPS), PLOTSYMBOL(NOBSGPS), WTMULTIPLIER(NOBSGPS), COVMATNAM(NOBSGPS), &
             GPSTATISTIC(NOBSGPS), GPSTATFLAG(NOBSGPS), &
             GPNONDETECT(NOBSGPS), GPWTOSCONSTANT(NOBSGPS))
    !   Assign default attribute values
    USEFLAG = .TRUE.
    PLOTSYMBOL = 1
    WTMULTIPLIER = 1.0D0
    COVMATNAM = ''
    GPSTATISTIC = 10.0D38
    GPSTATFLAG = 'UNKNOWN'
    GPNONDETECT = .FALSE.
    GPWTOSCONSTANT = 0.0D0
    !   Populate arrays with data from input block
    CALL UTL_FILTERLIST(LLPTRDEPGP, IOUT, 'USEFLAG', NOBSGPS, IERR, USEFLAG, MORE)
    CALL UTL_FILTERLIST(LLPTRDEPGP, IOUT, 'PLOTSYMBOL', NOBSGPS, IERR, PLOTSYMBOL, MORE)
    CALL UTL_FILTERLIST(LLPTRDEPGP, IOUT, 'WTMULTIPLIER', NOBSGPS, IERR, WTMULTIPLIER, MORE)
    CALL UTL_FILTERLIST(LLPTRDEPGP, IOUT, 'COVMATRIX', NOBSGPS, IERR, COVMATNAM, MORE)
    CALL UTL_FILTERLIST(LLPTRDEPGP, IOUT, 'STATISTIC', NOBSGPS, IERR, GPSTATISTIC, MORE)
    CALL UTL_FILTERLIST(LLPTRDEPGP, IOUT, 'STATFLAG', NOBSGPS, IERR, GPSTATFLAG, MORE)
    CALL UTL_FILTERLIST(LLPTRDEPGP, IOUT, 'NONDETECT', NOBSGPS, IERR, GPNONDETECT, MORE)
    CALL UTL_FILTERLIST(LLPTRDEPGP, IOUT, 'WTOSCONSTANT', NOBSGPS, IERR, GPWTOSCONSTANT, MORE)
  ENDIF
  RETURN
END SUBROUTINE AJ_INI_OBSERVATION_GROUPS
!
!###############################################################################
!
SUBROUTINE AJ_INI_OBSERVATION_DATA(NOBS)
  !DEC$ ATTRIBUTES DLLEXPORT::AJ_INI_OBSERVATION_DATA
  !DEC$ ATTRIBUTES ALIAS:'aj_ini_observation_data' :: AJ_INI_OBSERVATION_DATA
  ! Read Observation_Data input block
  USE GLOBAL_DATA, ONLY: IVERB, BIGREAL
  USE DATATYPES
  USE UTILITIES
  USE DEPENDENTS, ONLY: GROUPNAM, LLPTRDEP, NOBSGPS, &
                        PLOTSYMBOL, USEFLAG, WTMULTIPLIER, COVMATNAM, &
                        NOBSCOLS, OBSCOL, OBSALLNAM, OBSVAL, GROUPNOBS
  USE UCODE_DATA, ONLY: INUNIT, IOUT, TAIL, STATISTIC, STATFLAG, &
                        NONDETECT, WTOSCONSTANT, DEROBSEQN 
  IMPLICIT NONE
  !   Argument-list variables
  INTEGER, INTENT(INOUT) :: NOBS
  !
  !   Local variables
  CHARACTER(LEN=16)  :: BLABEL = 'OBSERVATION_DATA'      ! Block label
  CHARACTER(LEN=9)   :: KITEM = 'OBSNAME'       ! Key item
  LOGICAL            :: REQUIRED = .FALSE.
  INTEGER :: IERR, MORE      
  !
  NOBS = 0
  CALL UTL_READBLOCK(NOBSCOLS,BLABEL,OBSCOL,INUNIT,IOUT,  &
                     KITEM,REQUIRED,LLPTRDEP,TAIL,NOBS)
  IF (IVERB>4) CALL UTL_WRITEBLOCK(LLPTRDEP,IOUT)
  IF (NOBS > 0) THEN
    ALLOCATE(STATISTIC(NOBS), STATFLAG(NOBS), &
             NONDETECT(NOBS), WTOSCONSTANT(NOBS), OBSALLNAM(NOBS), OBSVAL(NOBS), &
             GROUPNOBS(NOBS), DEROBSEQN(NOBS))
    !   Assign default attribute values
    NONDETECT = .FALSE.
    WTOSCONSTANT = 0.0D0
    DEROBSEQN = '_'
    OBSALLNAM = ''
    OBSVAL = 10.0D38
    GROUPNOBS = 'DefaultObs'
    STATISTIC = 10.0D38
    STATFLAG = 'UNKNOWN'
    !   Populate arrays with data from input block
    CALL UTL_FILTERLIST(LLPTRDEP, IOUT, 'OBSNAME', NOBS, IERR, OBSALLNAM, MORE)
    CALL UTL_FILTERLIST(LLPTRDEP, IOUT, 'OBSVALUE', NOBS, IERR, OBSVAL, MORE)
    CALL UTL_FILTERLIST(LLPTRDEP, IOUT, 'STATISTIC', NOBS, IERR, STATISTIC, MORE)
    CALL UTL_FILTERLIST(LLPTRDEP, IOUT, 'STATFLAG', NOBS, IERR, STATFLAG, MORE)
    CALL UTL_FILTERLIST(LLPTRDEP, IOUT, 'GROUPNAME', NOBS, IERR, GROUPNOBS, MORE)
    CALL UTL_FILTERLIST(LLPTRDEP, IOUT, 'EQUATION', NOBS, IERR, DEROBSEQN, MORE)
    CALL UTL_FILTERLIST(LLPTRDEP, IOUT, 'NONDETECT', NOBS, IERR, NONDETECT, MORE)
    CALL UTL_FILTERLIST(LLPTRDEP, IOUT, 'WTOSCONSTANT', NOBS, IERR, WTOSCONSTANT, MORE)
  ENDIF
  RETURN
END SUBROUTINE AJ_INI_OBSERVATION_DATA
!
!###############################################################################
!
SUBROUTINE AJ_INI_PREDICTION_GROUPS(NPREDGP)
  !DEC$ ATTRIBUTES DLLEXPORT::AJ_INI_PREDICTION_GROUPS
  !DEC$ ATTRIBUTES ALIAS:'aj_ini_prediction_groups' :: AJ_INI_PREDICTION_GROUPS
  ! Read Prediction_Groups input block, if present
  USE GLOBAL_DATA, ONLY: IVERB, BIGREAL
  USE DATATYPES
  USE UTILITIES
  USE UCODE_DATA, ONLY: PREDGROUPNAME, LLPTRPREDGP, NPREDGPS, &
                        PREDPLOTSYMBOL, PREDUSEFLAG
  USE UCODE_DATA, ONLY: INUNIT, IOUT, TAIL, GPMEASSTATISTIC, GPMEASSTATFLAG, &
                        GPREFVALUE
  IMPLICIT NONE
  !   Argument-list variables
  INTEGER, INTENT(INOUT) :: NPREDGP
  !
  !   Local variables
  INTEGER, PARAMETER :: NDEFCOLS = 0
  CHARACTER(LEN=20)  :: BLABEL = 'PREDICTION_GROUPS'      ! Block label
  CHARACTER(LEN=40), DIMENSION(NDEFCOLS) :: COLNAMES
  CHARACTER(LEN=9)   :: KITEM = 'GROUPNAME'       ! Key item
  LOGICAL            :: REQUIRED = .FALSE.
  INTEGER :: IERR, MORE
      
  !
  NPREDGPS = 0
  CALL UTL_READBLOCK(NDEFCOLS,BLABEL,COLNAMES,INUNIT,IOUT,  &
                     KITEM,REQUIRED,LLPTRPREDGP,TAIL,NPREDGPS)
  NPREDGP = NPREDGPS
  IF (IVERB>4) CALL UTL_WRITEBLOCK(LLPTRPREDGP,IOUT)
  IF (NPREDGPS > 0) THEN
    ALLOCATE(PREDGROUPNAME(NPREDGPS))
    CALL UTL_FILTERLIST(LLPTRPREDGP, IOUT, 'GROUPNAME', NPREDGPS, IERR, PREDGROUPNAME, MORE)
    ALLOCATE(PREDUSEFLAG(NPREDGPS), PREDPLOTSYMBOL(NPREDGPS), &
             GPMEASSTATISTIC(NPREDGPS), GPMEASSTATFLAG(NPREDGPS), GPREFVALUE(NPREDGPS))
    !   Assign default attribute values
    PREDUSEFLAG = .TRUE.
    PREDPLOTSYMBOL = 1
    GPMEASSTATISTIC = 10.0D38
    GPMEASSTATFLAG = 'UNKNOWN'
    GPREFVALUE = 10.0D38
    !   Populate arrays with data from input block
    CALL UTL_FILTERLIST(LLPTRPREDGP, IOUT, 'USEFLAG', NPREDGPS, IERR, PREDUSEFLAG, MORE)
    CALL UTL_FILTERLIST(LLPTRPREDGP, IOUT, 'PLOTSYMBOL', NPREDGPS, IERR, PREDPLOTSYMBOL, MORE)
    CALL UTL_FILTERLIST(LLPTRPREDGP, IOUT, 'REFVALUE', NPREDGPS, IERR, GPREFVALUE, MORE)
    CALL UTL_FILTERLIST(LLPTRPREDGP, IOUT, 'MEASSTATISTIC', NPREDGPS, IERR, GPMEASSTATISTIC, MORE)
    CALL UTL_FILTERLIST(LLPTRPREDGP, IOUT, 'MEASSTATFLAG', NPREDGPS, IERR, GPMEASSTATFLAG, MORE)
  ENDIF
  RETURN
END SUBROUTINE AJ_INI_PREDICTION_GROUPS
!
!###############################################################################
!
SUBROUTINE AJ_INI_PREDICTION_DATA(NPRED)
  !DEC$ ATTRIBUTES DLLEXPORT::AJ_INI_PREDICTION_DATA
  !DEC$ ATTRIBUTES ALIAS:'aj_ini_prediction_data' :: AJ_INI_PREDICTION_DATA
  ! Read Prediction_Data input block
  USE GLOBAL_DATA, ONLY: IVERB, BIGREAL
  USE DATATYPES
  USE UTILITIES
  USE UCODE_DATA, ONLY: LLPTRPRED, NPREDGPS, &
                        PREDPLOTSYMBOL, PREDUSEFLAG,  &
                        NPREDCOLS, PREDCOL, PREDNAME, REFVALUE, GROUPNPRED
  USE UCODE_DATA, ONLY: INUNIT, IOUT, TAIL, MEASSTATISTIC, MEASSTATFLAG, &
                        DERPREDEQN 
  IMPLICIT NONE
  !   Argument-list variables
  INTEGER, INTENT(INOUT) :: NPRED
  !
  !   Local variables
  CHARACTER(LEN=16)  :: BLABEL = 'PREDICTION_DATA'      ! Block label
  CHARACTER(LEN=9)   :: KITEM = 'PREDNAME'       ! Key item
  LOGICAL            :: REQUIRED = .FALSE.
  INTEGER :: IERR, MORE
      
  !
  NPRED = 0
  CALL UTL_READBLOCK(NPREDCOLS,BLABEL,PREDCOL,INUNIT,IOUT,  &
                     KITEM,REQUIRED,LLPTRPRED,TAIL,NPRED)
  IF (IVERB>4) CALL UTL_WRITEBLOCK(LLPTRPRED,IOUT)
  IF (NPRED > 0) THEN
    ALLOCATE(PREDNAME(NPRED))
    CALL UTL_FILTERLIST(LLPTRPRED, IOUT, 'PREDNAME', NPRED, IERR, PREDNAME, MORE)
    ALLOCATE(MEASSTATISTIC(NPRED), MEASSTATFLAG(NPRED), &
             REFVALUE(NPRED), &
             GROUPNPRED(NPRED), DERPREDEQN(NPRED))
    !   Assign default attribute values
    MEASSTATISTIC = 10.0D38
    MEASSTATFLAG = 'UNKNOWN'
    REFVALUE = 0.0D0
    GROUPNPRED = 'DefaultPreds'
    DERPREDEQN = '_'
    !   Populate arrays with data from input block
    CALL UTL_FILTERLIST(LLPTRPRED, IOUT, 'PREDNAME', NPRED, IERR, PREDNAME, MORE)
    CALL UTL_FILTERLIST(LLPTRPRED, IOUT, 'REFVALUE', NPRED, IERR, REFVALUE, MORE)
    CALL UTL_FILTERLIST(LLPTRPRED, IOUT, 'MEASSTATISTIC', NPRED, IERR, MEASSTATISTIC, MORE)
    CALL UTL_FILTERLIST(LLPTRPRED, IOUT, 'MEASSTATFLAG', NPRED, IERR, MEASSTATFLAG, MORE)
    CALL UTL_FILTERLIST(LLPTRPRED, IOUT, 'GROUPNAME', NPRED, IERR, GROUPNPRED, MORE)
    CALL UTL_FILTERLIST(LLPTRPRED, IOUT, 'EQUATION', NPRED, IERR, DERPREDEQN, MORE)
  ENDIF
  RETURN
END SUBROUTINE AJ_INI_PREDICTION_DATA
!
!###############################################################################
!
SUBROUTINE AJ_INI_PRIOR_INFORMATION_GROUPS(NPRIGP)
  !DEC$ ATTRIBUTES DLLEXPORT::AJ_INI_PRIOR_INFORMATION_GROUPS
  !DEC$ ATTRIBUTES ALIAS:'aj_ini_prior_information_groups' :: AJ_INI_PRIOR_INFORMATION_GROUPS
  ! Read Prior_Information_Groups input block, if present
  USE GLOBAL_DATA, ONLY: IVERB, BIGREAL
  USE DATATYPES
  USE UTILITIES
  USE UCODE_DATA, ONLY: PRIGROUPNAME, LLPTRPRIGP, NPRIGPS, &
                        PRIPLOTSYMBOL, PRIUSEFLAG, PRIWTMULTIPLIER
  USE UCODE_DATA, ONLY: INUNIT, IOUT, TAIL, GPPRISTATISTIC, GPPRISTATFLAG, &
                        GPPRIORINFOVALUE
  IMPLICIT NONE
  !   Argument-list variables
  INTEGER, INTENT(INOUT) :: NPRIGP
  !
  !   Local variables
  INTEGER, PARAMETER :: NDEFCOLS = 0
  CHARACTER(LEN=30)  :: BLABEL = 'PRIOR_INFORMATION_GROUPS'      ! Block label
  CHARACTER(LEN=40), DIMENSION(NDEFCOLS) :: COLNAMES
  CHARACTER(LEN=9)   :: KITEM = 'GROUPNAME'       ! Key item
  LOGICAL            :: REQUIRED = .FALSE.
  INTEGER :: IERR, MORE
  !
  NPRIGPS = 0
  CALL UTL_READBLOCK(NDEFCOLS,BLABEL,COLNAMES,INUNIT,IOUT,  &
                     KITEM,REQUIRED,LLPTRPRIGP,TAIL,NPRIGPS)
  NPRIGP = NPRIGPS
  IF (IVERB>4) CALL UTL_WRITEBLOCK(LLPTRPRIGP,IOUT)
  IF (NPRIGPS > 0) THEN
    ALLOCATE(PRIGROUPNAME(NPRIGPS))
    CALL UTL_FILTERLIST(LLPTRPRIGP, IOUT, 'GROUPNAME', NPRIGPS, IERR, PRIGROUPNAME, MORE)
    ALLOCATE(PRIUSEFLAG(NPRIGPS), PRIPLOTSYMBOL(NPRIGPS), &
             GPPRISTATISTIC(NPRIGPS), GPPRISTATFLAG(NPRIGPS), GPPRIORINFOVALUE(NPRIGPS), &
             PRIWTMULTIPLIER(NPRIGPS))
    !   Assign default attribute values
    PRIUSEFLAG = .TRUE.
    PRIPLOTSYMBOL = 1
    GPPRISTATISTIC = 10.0D38
    GPPRISTATFLAG = 'UNKNOWN'
    GPPRIORINFOVALUE = 10.0D38
    PRIWTMULTIPLIER = 10.0D38
    !   Populate arrays with data from input block
    CALL UTL_FILTERLIST(LLPTRPRIGP, IOUT, 'USEFLAG', NPRIGPS, IERR, PRIUSEFLAG, MORE)
    CALL UTL_FILTERLIST(LLPTRPRIGP, IOUT, 'PLOTSYMBOL', NPRIGPS, IERR, PRIPLOTSYMBOL, MORE)
    CALL UTL_FILTERLIST(LLPTRPRIGP, IOUT, 'WTMULTIPLIER', NPRIGPS, IERR, PRIWTMULTIPLIER, MORE)
    CALL UTL_FILTERLIST(LLPTRPRIGP, IOUT, 'PRIORINFOVALUE', NPRIGPS, IERR, GPPRIORINFOVALUE, MORE)
    CALL UTL_FILTERLIST(LLPTRPRIGP, IOUT, 'STATISTIC', NPRIGPS, IERR, GPPRISTATISTIC, MORE)
    CALL UTL_FILTERLIST(LLPTRPRIGP, IOUT, 'STATFLAG', NPRIGPS, IERR, GPPRISTATFLAG, MORE)
  ENDIF
  RETURN
END SUBROUTINE AJ_INI_PRIOR_INFORMATION_GROUPS
!
!###############################################################################
!
SUBROUTINE AJ_INI_LINEAR_PRIOR_INFORMATION(NPRI)
  !DEC$ ATTRIBUTES DLLEXPORT::AJ_INI_LINEAR_PRIOR_INFORMATION
  !DEC$ ATTRIBUTES ALIAS:'aj_ini_linear_prior_information' :: AJ_INI_LINEAR_PRIOR_INFORMATION
  ! Read Linear_Prior_Information input block
  USE GLOBAL_DATA, ONLY: IVERB, BIGREAL
  USE DATATYPES
  USE UTILITIES
  USE UCODE_DATA, ONLY: LLPTRPRI, NPRIGPS, &
                        PRIPLOTSYMBOL, PRIUSEFLAG,  &
                        NPRICOLS, PRICOL, PRIORNAME, PRIORINFOVALUE, GROUPNPRI
  USE UCODE_DATA, ONLY: INUNIT, IOUT, TAIL, PRISTATISTIC, PRISTATFLAG, &
                        PRIEQN 
  IMPLICIT NONE
  !   Argument-list variables
  INTEGER, INTENT(INOUT) :: NPRI
  !
  !   Local variables
  CHARACTER(LEN=30)  :: BLABEL = 'LINEAR_PRIOR_INFORMATION'      ! Block label
  CHARACTER(LEN=9)   :: KITEM = 'PRIORNAME'       ! Key item
  LOGICAL            :: REQUIRED = .FALSE.
  INTEGER :: IERR, MORE
      
  !
  NPRI = 0
  CALL UTL_READBLOCK(NPRICOLS,BLABEL,PRICOL,INUNIT,IOUT,  &
                     KITEM,REQUIRED,LLPTRPRI,TAIL,NPRI)
  IF (IVERB>4) CALL UTL_WRITEBLOCK(LLPTRPRI,IOUT)
  IF (NPRI > 0) THEN
    ALLOCATE(PRIORNAME(NPRI)) 
    ALLOCATE(PRISTATISTIC(NPRI))
    ALLOCATE(PRISTATFLAG(NPRI))
    ALLOCATE(PRIORINFOVALUE(NPRI))
    ALLOCATE(GROUPNPRI(NPRI))
    ALLOCATE(PRIEQN(NPRI))
    !   Assign default attribute values
    PRIORNAME = ''
    PRISTATISTIC = 10.0D38
    PRISTATFLAG = 'UNKNOWN'
    PRIORINFOVALUE = 10.0D38
    GROUPNPRI = 'DefaultPrior'
    PRIEQN = '_'
    !   Populate arrays with data from input block
    CALL UTL_FILTERLIST(LLPTRPRI, IOUT, 'PRIORNAME', NPRI, IERR, PRIORNAME, MORE)
    CALL UTL_FILTERLIST(LLPTRPRI, IOUT, 'PRIORINFOVALUE', NPRI, IERR, PRIORINFOVALUE, MORE)
    CALL UTL_FILTERLIST(LLPTRPRI, IOUT, 'STATISTIC', NPRI, IERR, PRISTATISTIC, MORE)
    CALL UTL_FILTERLIST(LLPTRPRI, IOUT, 'STATFLAG', NPRI, IERR, PRISTATFLAG, MORE)
    CALL UTL_FILTERLIST(LLPTRPRI, IOUT, 'GROUPNAME', NPRI, IERR, GROUPNPRI, MORE)
    CALL UTL_FILTERLIST(LLPTRPRI, IOUT, 'EQUATION', NPRI, IERR, PRIEQN, MORE)
  ENDIF
  RETURN
END SUBROUTINE AJ_INI_LINEAR_PRIOR_INFORMATION
!
!###############################################################################
!
SUBROUTINE AJ_INI_MODEL_INPUT_FILES(NMIPAIRS)
  !DEC$ ATTRIBUTES DLLEXPORT::AJ_INI_MODEL_INPUT_FILES
  !DEC$ ATTRIBUTES ALIAS:'aj_ini_model_input_files' :: AJ_INI_MODEL_INPUT_FILES
  USE MODEL_IO, ONLY: LLPTRMODIN, MIO_INI_INPUTFILES, NUMINFILE
  USE UCODE_DATA, ONLY: INUNIT, IOUT
  IMPLICIT NONE
  INTEGER, INTENT(INOUT) :: NMIPAIRS
  !
  NMIPAIRS = 0
  CALL MIO_INI_INPUTFILES(INUNIT,IOUT)
  NMIPAIRS = NUMINFILE
  RETURN
END SUBROUTINE AJ_INI_MODEL_INPUT_FILES
!
!###############################################################################
!
SUBROUTINE AJ_INI_MODEL_OUTPUT_FILES(NMOPAIRS)
  !DEC$ ATTRIBUTES DLLEXPORT::AJ_INI_MODEL_OUTPUT_FILES
  !DEC$ ATTRIBUTES ALIAS:'aj_ini_model_output_files' :: AJ_INI_MODEL_OUTPUT_FILES
  USE MODEL_IO, ONLY: LLPTRMODIN, MIO_INI_OUTPUTFILES, NUMOUTFILE
  USE UCODE_DATA, ONLY: INUNIT, IOUT
  IMPLICIT NONE
  INTEGER, INTENT(INOUT) :: NMOPAIRS
  !
  NMOPAIRS = 0
  CALL MIO_INI_OUTPUTFILES(INUNIT,IOUT)
  NMOPAIRS = NUMOUTFILE
  RETURN
END SUBROUTINE AJ_INI_MODEL_OUTPUT_FILES
!
!###############################################################################
!
SUBROUTINE AJ_INI_PARALLEL(KCTRL,NUMRUNNRS,IPARALLEL,DWAIT,DWAITRUNNERS, &
                           IVERBRUN,IAUTOSTOP,DTIMEOUT)
  !DEC$ ATTRIBUTES DLLEXPORT::AJ_INI_PARALLEL
  !DEC$ ATTRIBUTES ALIAS:'aj_ini_parallel' :: AJ_INI_PARALLEL
  USE UTILITIES
  USE AJ_MOD
  USE PARALLEL_DATA
  USE UCODE_DATA, ONLY: INUNIT, IOUT
  IMPLICIT NONE
  INTEGER, INTENT(INOUT) :: KCTRL, NUMRUNNRS
  INTEGER, INTENT(INOUT) :: IPARALLEL, IVERBRUN, IAUTOSTOP
  DOUBLE PRECISION, INTENT(INOUT) :: DWAIT, DWAITRUNNERS, DTIMEOUT
  !
  !   Local variables
  CHARACTER(LEN=40), DIMENSION(0) :: COLNAMES
  INTEGER :: IERR, MORE
  NULLIFY(LLPTRPLLCTRL,LLPTRPLLRUN,TAIL)
  !
  !   Assign defaults
  DOPLL = .FALSE.
  WAITPLL = 0.001D0
  WAITRUNNERSPLL = 0.0D0
  IVERBRUNNER = 3
  AUTOSTOPRUNNERS = .TRUE.
  TIMEOUTFAC = 3.0D0
  KCTRL = 0
  NUMRUNNRS = 0
  !
  CALL UTL_READBLOCK(0,'PARALLEL_CONTROL',COLNAMES,INUNIT,IOUT,'*',   &
                     .FALSE.,LLPTRPLLCTRL,TAIL,KCTRL)
  CALL UTL_READBLOCK(NRUNNERCOLS,'PARALLEL_RUNNERS',RUNNERCOLS,INUNIT,   &
                     IOUT,'RUNNERNAME',.FALSE.,LLPTRPLLRUN,TAIL,NUMRUNNERS)
  NUMRUNNRS = NUMRUNNERS
  IF (KCTRL>0) THEN
    !   Assign variables
    CALL UTL_FILTER(IERR,LLPTRPLLCTRL,IOUT,'PARALLEL',DOPLL)
    CALL UTL_FILTER(IERR,LLPTRPLLCTRL,IOUT,'WAIT',WAITPLL)
    CALL UTL_FILTER(IERR,LLPTRPLLCTRL,IOUT,'WAITRUNNERS',WAITRUNNERSPLL)
    CALL UTL_FILTER(IERR,LLPTRPLLCTRL,IOUT,'VERBOSERUNNER',IVERBRUNNER)
    CALL UTL_FILTER(IERR,LLPTRPLLCTRL,IOUT,'AUTOSTOPRUNNERS',   &
                    AUTOSTOPRUNNERS)
    CALL UTL_FILTER(IERR,LLPTRPLLCTRL,IOUT,'TIMEOUTFACTOR',TIMEOUTFAC)
  ENDIF
  ALLOCATE(RUNTIME(NUMRUNNERS), RUNNERDIR(NUMRUNNERS), &
           RUNNERNAME(NUMRUNNERS))
  IF (NUMRUNNERS > 0) THEN
    !   Populate arrays
    RUNTIME = 10.0D0
    CALL UTL_FILTERLIST(LLPTRPLLRUN,IOUT,'RUNNERNAME',NUMRUNNERS,IERR,   &
                        RUNNERNAME,MORE)
    CALL UTL_FILTERLIST(LLPTRPLLRUN,IOUT,'RUNNERDIR',NUMRUNNERS,IERR,   &
                        RUNNERDIR,MORE)
    CALL UTL_FILTERLIST(LLPTRPLLRUN,IOUT,'RUNTIME',NUMRUNNERS,IERR,   &
                        RUNTIME,MORE)
  ENDIF
  IPARALLEL = LOG2INT(DOPLL)
  DWAIT = WAITPLL
  DWAITRUNNERS = WAITPLL
  IF (WAITRUNNERSPLL .NE. 0.0D0) THEN
    DWAITRUNNERS = WAITRUNNERSPLL
  ENDIF
  IVERBRUN = IVERBRUNNER
  IAUTOSTOP = LOG2INT(AUTOSTOPRUNNERS)
  DTIMEOUT = TIMEOUTFAC
  RETURN
END SUBROUTINE AJ_INI_PARALLEL
!
!###############################################################################
!##############################    AJ_CLN    ###################################
!###############################################################################
!
SUBROUTINE AJ_CLN()
  !DEC$ ATTRIBUTES DLLEXPORT::AJ_CLN
  !DEC$ ATTRIBUTES ALIAS:'aj_cln' :: AJ_CLN
  USE BASIC
  USE DATATYPES
  USE UCODE_DATA
  USE DEPENDENTS, ONLY: COVMATNAM, GROUPNAM, GROUPNOBS, OBSALLNAM, &
                        WTMULTIPLIER, OBSVAL, PLOTSYMBOL, USEFLAG
  USE MODEL_IO, ONLY: INSFILE, MODINFILE, MODOUTFILE, TEMPFILE, &
                      MIO_CLN_OUTFILES, MIO_CLN_DEALLOC
  USE PARALLEL_DATA, ONLY: RUNNERNAME, RUNNERDIR, RUNTIME

  IMPLICIT NONE
  INTEGER :: IFAIL
  !
  !   Deallocate arrays
  IF (ALLOCATED(PARGP)) DEALLOCATE(PARGP)
  IF (ALLOCATED(GPLOWERVALUE)) DEALLOCATE(GPLOWERVALUE)
  IF (ALLOCATED(GPUPPERVALUE)) DEALLOCATE(GPUPPERVALUE)
  IF (ALLOCATED(GPLOWERCONSTRAINT)) DEALLOCATE(GPLOWERCONSTRAINT)
  IF (ALLOCATED(GPUPPERCONSTRAINT)) DEALLOCATE(GPUPPERCONSTRAINT)
  IF (ALLOCATED(GPPERTURBAMT)) DEALLOCATE(GPPERTURBAMT)
  IF (ALLOCATED(GPTOLPAR)) DEALLOCATE(GPTOLPAR)
  IF (ALLOCATED(GPMAXCHANGE)) DEALLOCATE(GPMAXCHANGE)
  IF (ALLOCATED(GPSCALEPVAL)) DEALLOCATE(GPSCALEPVAL)
  IF (ALLOCATED(GPCONSTRAIN)) DEALLOCATE(GPCONSTRAIN)
  IF (ALLOCATED(GPADJUSTABLE)) DEALLOCATE(GPADJUSTABLE)
  IF (ALLOCATED(GPTRANSFORM)) DEALLOCATE(GPTRANSFORM)
  IF (ALLOCATED(GPNONLINEARINT)) DEALLOCATE(GPNONLINEARINT)
  IF (ALLOCATED(GPSENMETHOD)) DEALLOCATE(GPSENMETHOD)
  IF (ALLOCATED(GPSOSINCREMENT)) DEALLOCATE(GPSOSINCREMENT)

  IF (ALLOCATED(PARNAM)) DEALLOCATE(PARNAM)
  IF (ALLOCATED(GROUPNAME)) DEALLOCATE(GROUPNAME)
  IF (ALLOCATED(LOWERVALUE)) DEALLOCATE(LOWERVALUE)
  IF (ALLOCATED(UPPERVALUE)) DEALLOCATE(UPPERVALUE)
  IF (ALLOCATED(LOWERCONSTRAINT)) DEALLOCATE(LOWERCONSTRAINT)
  IF (ALLOCATED(UPPERCONSTRAINT)) DEALLOCATE(UPPERCONSTRAINT)
  IF (ALLOCATED(PERTURBAMT)) DEALLOCATE(PERTURBAMT)
  IF (ALLOCATED(TOLPAR)) DEALLOCATE(TOLPAR)
  IF (ALLOCATED(MAXCHANGE)) DEALLOCATE(MAXCHANGE)
  IF (ALLOCATED(SCALEPVAL)) DEALLOCATE(SCALEPVAL)
  IF (ALLOCATED(STARTVALUE)) DEALLOCATE(STARTVALUE)
  IF (ALLOCATED(CONSTRAIN)) DEALLOCATE(CONSTRAIN)
  IF (ALLOCATED(ADJUSTABLE)) DEALLOCATE(ADJUSTABLE)
  IF (ALLOCATED(TRANSFORM)) DEALLOCATE(TRANSFORM)
  IF (ALLOCATED(NONLINEARINT)) DEALLOCATE(NONLINEARINT)
  IF (ALLOCATED(SENMETHOD)) DEALLOCATE(SENMETHOD)
  IF (ALLOCATED(SOSINCREMENT)) DEALLOCATE(SOSINCREMENT)

  IF (ALLOCATED(DERPARNAME)) DEALLOCATE(DERPARNAME)
  IF (ALLOCATED(DERPAREQN)) DEALLOCATE(DERPAREQN)
  IF (ALLOCATED(GROUPNAM)) DEALLOCATE(GROUPNAM)
  IF (ALLOCATED(USEFLAG)) DEALLOCATE(USEFLAG)
  IF (ALLOCATED(PLOTSYMBOL)) DEALLOCATE(PLOTSYMBOL)
  IF (ALLOCATED(WTMULTIPLIER)) DEALLOCATE(WTMULTIPLIER)
  IF (ALLOCATED(COVMATNAM)) DEALLOCATE(COVMATNAM)
  IF (ALLOCATED(GPSTATISTIC)) DEALLOCATE(GPSTATISTIC)
  IF (ALLOCATED(GPSTATFLAG)) DEALLOCATE(GPSTATFLAG)
  IF (ALLOCATED(GPNONDETECT)) DEALLOCATE(GPNONDETECT)
  IF (ALLOCATED(GPWTOSCONSTANT)) DEALLOCATE(GPWTOSCONSTANT)
  IF (ALLOCATED(OBSALLNAM)) DEALLOCATE(OBSALLNAM)
  IF (ALLOCATED(STATISTIC)) DEALLOCATE(STATISTIC)
  IF (ALLOCATED(STATFLAG)) DEALLOCATE(STATFLAG)
  IF (ALLOCATED(NONDETECT)) DEALLOCATE(NONDETECT)
  IF (ALLOCATED(WTOSCONSTANT)) DEALLOCATE(WTOSCONSTANT)
  IF (ALLOCATED(OBSVAL)) DEALLOCATE(OBSVAL)
  IF (ALLOCATED(GROUPNOBS)) DEALLOCATE(GROUPNOBS)
  IF (ALLOCATED(DEROBSEQN)) DEALLOCATE(DEROBSEQN)
  IF (ALLOCATED(PREDGROUPNAME)) DEALLOCATE(PREDGROUPNAME)
  IF (ALLOCATED(PREDUSEFLAG)) DEALLOCATE(PREDUSEFLAG)
  IF (ALLOCATED(PREDPLOTSYMBOL)) DEALLOCATE(PREDPLOTSYMBOL)
  IF (ALLOCATED(GPMEASSTATISTIC)) DEALLOCATE(GPMEASSTATISTIC)
  IF (ALLOCATED(GPMEASSTATFLAG)) DEALLOCATE(GPMEASSTATFLAG)
  IF (ALLOCATED(GPREFVALUE)) DEALLOCATE(GPREFVALUE)
  IF (ALLOCATED(PREDNAME)) DEALLOCATE(PREDNAME)
  IF (ALLOCATED(MEASSTATISTIC)) DEALLOCATE(MEASSTATISTIC)
  IF (ALLOCATED(MEASSTATFLAG)) DEALLOCATE(MEASSTATFLAG)
  IF (ALLOCATED(REFVALUE)) DEALLOCATE(REFVALUE)
  IF (ALLOCATED(GROUPNPRED)) DEALLOCATE(GROUPNPRED)
  IF (ALLOCATED(DERPREDEQN)) DEALLOCATE(DERPREDEQN)
  IF (ALLOCATED(PRIGROUPNAME)) DEALLOCATE(PRIGROUPNAME)
  IF (ALLOCATED(PRIUSEFLAG)) DEALLOCATE(PRIUSEFLAG)
  IF (ALLOCATED(PRIPLOTSYMBOL)) DEALLOCATE(PRIPLOTSYMBOL)
  IF (ALLOCATED(GPPRISTATISTIC)) DEALLOCATE(GPPRISTATISTIC)
  IF (ALLOCATED(GPPRISTATFLAG)) DEALLOCATE(GPPRISTATFLAG)
  IF (ALLOCATED(GPPRIORINFOVALUE)) DEALLOCATE(GPPRIORINFOVALUE)
  IF (ALLOCATED(PRIWTMULTIPLIER)) DEALLOCATE(PRIWTMULTIPLIER)
  IF (ALLOCATED(PRIORNAME)) DEALLOCATE(PRIORNAME)
  IF (ALLOCATED(PRISTATISTIC)) DEALLOCATE(PRISTATISTIC)
  IF (ALLOCATED(PRISTATFLAG)) DEALLOCATE(PRISTATFLAG)
  IF (ALLOCATED(PRIORINFOVALUE)) DEALLOCATE(PRIORINFOVALUE)
  IF (ALLOCATED(GROUPNPRI)) DEALLOCATE(GROUPNPRI)
  IF (ALLOCATED(PRIEQN)) DEALLOCATE(PRIEQN)
  IF (ALLOCATED(RUNTIME)) DEALLOCATE(RUNTIME)
  IF (ALLOCATED(RUNNERDIR)) DEALLOCATE(RUNNERDIR)
  IF (ALLOCATED(RUNNERNAME)) DEALLOCATE(RUNNERNAME)
  !
  !   Deallocate arrays of JUPITER modules
  CALL TYP_DEALLOC(GNUCHEAD)
  CALL TYP_DEALLOC(UCODEHEAD)
  CALL BAS_CLN
  CALL MIO_CLN_DEALLOC
  CLOSE(INUNIT)
  CLOSE(IOUT)
  RETURN
END SUBROUTINE AJ_CLN
!
!###############################################################################
!###############################################################################
!###############################################################################
!
SUBROUTINE AJ_UTL_CASE(WORDIN,WORDOUT,ICASE)
  !DEC$ ATTRIBUTES DLLEXPORT::AJ_UTL_CASE
  !DEC$ ATTRIBUTES ALIAS:'aj_utl_case' :: AJ_UTL_CASE
  USE UTILITIES
  IMPLICIT NONE
  CHARACTER (LEN=*) :: WORDIN, WORDOUT
  INTEGER :: ICASE 
  !
  CALL UTL_CASE(WORDIN,WORDOUT,ICASE)
  !
  RETURN
END SUBROUTINE AJ_UTL_CASE
!
!###############################################################################
!
SUBROUTINE AJ_UTL_WRTSIG(IFAIL,VAL,WORD,NW,PRECPR,TVAL,NOPNT)
  !DEC$ ATTRIBUTES DLLEXPORT::AJ_UTL_WRTSIG
  !DEC$ ATTRIBUTES ALIAS:'aj_utl_wrtsig' :: AJ_UTL_WRTSIG
  USE UTILITIES
  IMPLICIT NONE
  INTEGER          :: IFAIL
  DOUBLE PRECISION :: VAL    ! Value to be written
  CHARACTER(LEN=*) :: WORD   ! Character representation of precision-limited value
  INTEGER          :: NW     ! Available field width
  INTEGER          :: PRECPR ! 0: single prec. (E) output;
                             ! 1: double prec. (E) output;
                             ! 2: double prec. (D) output
  DOUBLE PRECISION :: TVAL   ! Value written, truncated to available precision
  INTEGER          :: NOPNT
  !
  CALL UTL_WRTSIG(IFAIL,VAL,WORD,NW,PRECPR,TVAL,NOPNT)
  !
  RETURN
END SUBROUTINE AJ_UTL_WRTSIG
!
!###############################################################################
!
