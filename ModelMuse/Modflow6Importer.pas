{ @name is used to read a model feature input file generated by PEST for
  display in ModelMuse.
}
unit Modflow6Importer;

interface

uses
  System.Classes, System.SysUtils, System.IOUtils, ModflowCellUnit,
  System.Generics.Collections, ModflowMawUnit, ModflowSfr6Unit,
  ModflowLakMf6Unit, Modflow6TimeSeriesCollectionsUnit;

type
  TModflow6Feature = class(TObject)
  private
    FCell: TCellLocation;
  public
    property Cell: TCellLocation read FCell write FCell;
  end;

  TModflowFeatureList = TObjectList<TModflow6Feature>;

  TChdFeature = class(TModflow6Feature)
  private
    FHead: double;
  public
    property Head: double read FHead;
  end;

  TWellFeature = class(TModflow6Feature)
  private
    FQ: double;
  public
    property Q: double read FQ;
  end;

  TDrnFeature = class(TModflow6Feature)
  private
    FElev: double;
    FCond: double;
  public
    property Elev: double read FElev;
    property Cond: double read FCond;
  end;

  TRivFeature = class(TModflow6Feature)
  private
    FStage: double;
    FCond: double;
    FRBot: double;
  public
    property Stage: double read FStage;
    property Cond: double read FCond;
    property RBot: double read FRBot;
  end;

  TGhbFeature = class(TModflow6Feature)
  private
    FHead: double;
    FCond: double;
  public
    property Head: double read FHead;
    property Cond: double read FCond;
  end;

  TRchFeature = class(TModflow6Feature)
  private
    FRecharge: double;
  public
    property Recharge: double read FRecharge;
  end;

  TEvtFeature = class(TModflow6Feature)
  private
    FSurface: double;
    FRate: double;
    FDepth: double;
  public
    property Surface: double read FSurface;
    property Rate: double read FRate;
    property Depth: double read FDepth;
  end;

  TCSubFeature = class(TModflow6Feature)
  private
    FSig0: double;
  public
    property Sig0: double read FSig0;
  end;

  TMawRecord = record
  private
    FStatus: TMawStatus;
    FScalingLength: double;
    FPumpElevation: double;
    FHeadLimitUsed: Boolean;
    FFwcond: double;
    FFwelev: double;
    FHead_limit: double;
    FRateScaling: Boolean;
    FRate: double;
    FMaxRate: double;
    FShutOff: Boolean;
    FWell_Head: double;
    FFwrlen: double;
    FFlowingWell: Boolean;
    FMinRate: double;
  public
    procedure Initialize;
    property Status: TMawStatus read FStatus;
    property FlowingWell: Boolean read FFlowingWell;
    property Fwelev: double read FFwelev;
    property Fwcond: double read FFwcond;
    property Fwrlen: double read FFwrlen;
    property Rate: double read FRate;
    // used with Status = constant
    property Well_Head: double read FWell_Head;
    property HeadLimitUsed: Boolean read FHeadLimitUsed;
    property Head_limit: double read FHead_limit;
    property ShutOff: Boolean read FShutOff;
    property MinRate: double read FMinRate;
    property MaxRate: double read FMaxRate;
    property RateScaling: Boolean read FRateScaling;
    property PumpElevation: double read FPumpElevation;
    property ScalingLength: double read FScalingLength;
  end;

  TMawFeature = class(TModflow6Feature)
  private
    FMawProperties: TMawRecord;
  public
    property MawProperties: TMawRecord read FMawProperties;
  end;

  TSfrFeature = class(TModflow6Feature)
  private
    FRAINFALL: double;
    FMANNING: double;
    FUPSTREAM_FRACTION: double;
    FRUNOFF: double;
    FStatus: TStreamStatus;
    FINFLOW: double;
    FEVAPORATION: double;
    FSTAGE: double;
  public
    property Status: TStreamStatus read FStatus;
    property MANNING: double read FMANNING;
    property STAGE: double read FSTAGE;
    property INFLOW: double read FINFLOW;
    property RAINFALL: double read FRAINFALL;
    property EVAPORATION: double read FEVAPORATION;
    property RUNOFF: double read FRUNOFF;
    property UPSTREAM_FRACTION: double read FUPSTREAM_FRACTION;
    constructor Create;
  end;

  TLakeRecord = record
  private
    FRAINFALL: double;
    FRUNOFF: double;
    FStatus: TLakeStatus;
    FWITHDRAWAL: double;
    FINFLOW: double;
    FEVAPORATION: double;
    FStage: double;
  public
    property Status: TLakeStatus read FStatus;
    property Stage: double read FStage;
    property RAINFALL: double read FRAINFALL;
    property EVAPORATION: double read FEVAPORATION;
    property RUNOFF: double read FRUNOFF;
    property INFLOW: double read FINFLOW;
    property WITHDRAWAL: double read FWITHDRAWAL;
//    property RATE: double read FRATE;
//    property INVERT: double read FINVERT;
//    property WIDTH: double read FWIDTH;
//    property SLOPE: double read FSLOPE;
//    property ROUGH: double read FROUGH;
    procedure Initialize;
  end;

  TLakeFeature = class(TModflow6Feature)
  private
    FLakeProperties: TLakeRecord;
  public
    property LakeProperties: TLakeRecord read FLakeProperties;
  end;

  TUzfFeature = class(TModflow6Feature)
  private
    FExtwc: double;
    FExtdp: double;
    FPet: double;
    FRootAct: double;
    FHa: double;
    FFinf: double;
    FHRoot: double;
  public
    property Finf :double read FFinf;
    property Pet :double read FPet;
    property Extdp :double read FExtdp;
    property Extwc :double read FExtwc;
    property Ha :double read FHa;
    property HRoot :double read FHRoot;
    property RootAct :double read FRootAct;
  end;

  TModflow6FeatureType = (m6ftChd, m6ftWell, m6ftDrn, m6ftRiv, m6ftGhb,
    m6ftRch, m6ftEvt, m6ftCSub, m6ftMAW, m6ftSFR, m6ftLak, m6ftUzf);
  TModflow6GridType = (m6gtStructured, mggrDisv);

//  TCustomModflow6FileReader = class (TObject)
//  protected
//    FInputFile: TStreamReader;
//  public
//    constructor Create;
//    procedure OpenFile(const FileName: string); virtual;
//    destructor Destroy; override;
//  end;

  TModflow6FileReader = class (TObject)
  private
    FFeatureType: TModflow6FeatureType;
    FInputFile: TStreamReader;
    FGridType: TModflow6GridType;
    FNumberOfMawWells: Integer;
    FMawWellCells: array of array of TCellLocation;
    FNumberOfMawCells: Integer;
    FMawWellProperties: array of TMawRecord;
    FNumberOfReaches: Integer;
    FSfrFeatures: TObjectList<TSfrFeature>;
    FLakeProperties: array of TLakeRecord;
    FNumberOfLakes: integer;
    FLakeCells: array of array of TCellLocation;
    FNumberOfLakeCells: Integer;
    FUzfCells: array of TCellLocation;
    FNumberUzfCells: Integer;
    FTimeSeries: TTimesSeriesCollections;
    FStressPeriod: Integer;
    function ReadAFeature(const Splitter: TStringList): TModflow6Feature;
    function ReadAChdFeature(const Splitter: TStringList): TChdFeature;
    function ReadAWellFeature(const Splitter: TStringList): TWellFeature;
    function ReadADrnFeature(const Splitter: TStringList): TDrnFeature;
    function ReadARivFeature(const Splitter: TStringList): TRivFeature;
    function ReadAGhbFeature(const Splitter: TStringList): TGhbFeature;
    function ReadARchFeature(const Splitter: TStringList): TRchFeature;
    function ReadAEvtFeature(const Splitter: TStringList): TEvtFeature;
    function ReadACSubFeature(const Splitter: TStringList): TCSubFeature;
    function ReadAMawFeature(const Splitter: TStringList): TMawFeature;
    function ReadASfrFeature(const Splitter: TStringList): TSfrFeature;
    function ReadALakFeature(const Splitter: TStringList): TSfrFeature;
    function ReadAUzfFeature(const Splitter: TStringList): TUzfFeature;
    procedure ReadCell(Splitter: TStringList; AFeature: TModflow6Feature);
    procedure ReadNumberOfMawWells;
    procedure ReadMawWellCells;
    procedure ReadMawWellCellsPerWell;
    procedure InitializeMawWellProperties;
    procedure FinalizeMawFeatures(FeatureList: TModflowFeatureList);
    procedure ReadNumberOfSfrCells;
    procedure ReadSfrCells;
    function GetNumberOfItems(SearchItem: string): Integer;
    procedure FinalizeSfrFeatures(FeatureList: TModflowFeatureList);
    procedure ReadNumberOfLakes;
    procedure ReadNumberOfCellsPerLake;
    procedure ReadLakCells;
    procedure FinalizeLakeFeatures(FeatureList: TModflowFeatureList);
    procedure InitializeLakeProperties;
    procedure ReadNumberOfUzfCells;
    procedure ReadUzfCells;
    procedure ReadOptions;
    procedure ReadTimeSeriesFile(const TsFileName: string);
    function ReadFromTimeSeriesOrConvert(Text: string): double;
  public
    constructor Create(GridType: TModflow6GridType);
    procedure OpenFile(const FileName: string);
    function ReadStressPeriod(StressPeriod: Integer): TModflowFeatureList;
    destructor Destroy; override;
    property FeatureType: TModflow6FeatureType read FFeatureType;
  end;



//  TTimeSeriesReader = class(TCustomModflow6FileReader)
//  private
//    FInputFile: TStreamReader;
//    procedure ReadAttributes;
//    procedure ReadTimeSeries;
//  public
//    constructor Create;
//    procedure OpenFile(const FileName: string);
//    destructor Destroy; override;
//  end;

implementation

uses
  ModflowWellWriterUnit, ModelMuseUtilities, ModflowCHD_WriterUnit,
  ModflowDRN_WriterUnit, ModflowRiverWriterUnit, ModflowGHB_WriterUnit,
  ModflowRCH_WriterUnit, ModflowETS_WriterUnit, ModflowCSubWriterUnit,
  ModflowMawWriterUnit, ModflowSfr6WriterUnit, ModflowLakMf6WriterUnit,
  ModflowUzfMf6WriterUnit, PhastModelUnit, frmGoPhastUnit,
  Modflow6TimeSeriesUnit, GoPhastTypes;

{ TModflow6FileReader }

constructor TModflow6FileReader.Create(GridType: TModflow6GridType);
begin
  inherited Create;
  FGridType := GridType;
  FSfrFeatures := TObjectList<TSfrFeature>.Create;
  FTimeSeries := TTimesSeriesCollections.Create(nil);
end;

destructor TModflow6FileReader.Destroy;
begin
  FTimeSeries.Free;
  FInputFile.Free;
  FSfrFeatures.Free;
  inherited;
end;

function TModflow6FileReader.GetNumberOfItems(SearchItem: string): Integer;
var
  Splitter: TStringList;
  ALine: string;
begin
  result := 0;
  Splitter := TStringList.Create;
  try
    while not FInputFile.EndOfStream do
    begin
      ALine := ExtractNonCommentLine(FInputFile.ReadLine);
      if ALine = '' then
      begin
        Continue;
      end;
      Splitter.DelimitedText := ALine;
      if SameText(Splitter[0], SearchItem) then
      begin
        result := StrToInt(Splitter[1]);
        break;
      end;
      Assert(not IsEndOfSection(ALine));
    end;
  finally
    Splitter.Free;
  end;
end;

procedure TModflow6FileReader.FinalizeLakeFeatures(
  FeatureList: TModflowFeatureList);
var
  LakeIndex: Integer;
  CellIndex: Integer;
  LakFeature: TLakeFeature;
begin
  FeatureList.Clear;
  for LakeIndex := 0 to Length(FLakeProperties) - 1 do
  begin
    for CellIndex := 0 to Length(FLakeCells[LakeIndex]) - 1 do
    begin
      LakFeature := TLakeFeature.Create;
      LakFeature.FCell := FLakeCells[LakeIndex, CellIndex];
      LakFeature.FLakeProperties := FLakeProperties[LakeIndex];
      FeatureList.Add(LakFeature);
    end;
  end;
end;

procedure TModflow6FileReader.FinalizeMawFeatures(
  FeatureList: TModflowFeatureList);
var
  WellIndex: Integer;
  CellIndex: Integer;
  MawFeature: TMawFeature;
begin
  FeatureList.Clear;
  for WellIndex := 0 to Length(FMawWellProperties) - 1 do
  begin
    for CellIndex := 0 to Length(FMawWellCells[WellIndex]) - 1 do
    begin
      MawFeature := TMawFeature.Create;
      MawFeature.FCell := FMawWellCells[WellIndex, CellIndex];
      MawFeature.FMawProperties := FMawWellProperties[WellIndex];
      FeatureList.Add(MawFeature);
    end;
  end;
end;

procedure TModflow6FileReader.FinalizeSfrFeatures(FeatureList: TModflowFeatureList);
var
  Index: Integer;
begin
  FeatureList.Clear;
  FeatureList.Capacity := FSfrFeatures.Count;
  for Index := 0 to FSfrFeatures.Count - 1 do
  begin
    FeatureList.Add(FSfrFeatures[Index]);
  end;
  FSfrFeatures.OwnsObjects := False;
end;

procedure TModflow6FileReader.InitializeLakeProperties;
var
  Index: Integer;
begin
  for Index := 0 to Length(FLakeProperties) - 1 do
  begin
    FLakeProperties[Index].Initialize;
  end;
end;

procedure TModflow6FileReader.InitializeMawWellProperties;
var
  Index: Integer;
begin
  for Index := 0 to Length(FMawWellProperties) - 1 do
  begin
    FMawWellProperties[Index].Initialize;
  end;
end;

//function TModflow6FileReader.IsBeginningOfSection(const ALine: string;
//  out Section: string): Boolean;
//const
//  strBegin = 'BEGIN ';
//var
//  BeginPosition: Integer;
//begin
//  BeginPosition := Pos(strBegin, UpperCase(ALine));
//  result := BeginPosition = 1;
//  if result then
//  begin
//    Section := Copy(ALine, Length(strBegin)+1, MAXINT);
//  end
//  else
//  begin
//    Section := '';
//  end;
//end;

//function TModflow6FileReader.IsEndOfSection(const ALine: string): Boolean;
//begin
//  result := Pos('END', UpperCase(ALine)) = 1;
//end;
//
procedure TModflow6FileReader.OpenFile(const FileName: string);
var
  FileExtension: string;
begin
  FInputFile := TFile.OpenText(FileName);
  FileExtension := LowerCase(ExtractFileExt(FileName));
  if SameText(FileExtension, TModflowCHD_Writer.Extension) then
  begin
    FFeatureType := m6ftChd;
  end
  else if SameText(FileExtension, TModflowWEL_Writer.Extension) then
  begin
    FFeatureType := m6ftWell;
  end
  else if SameText(FileExtension, TModflowDRN_Writer.Extension) then
  begin
    FFeatureType := m6ftDrn;
  end
  else if SameText(FileExtension, TModflowRIV_Writer.Extension) then
  begin
    FFeatureType := m6ftRiv;
  end
  else if SameText(FileExtension, TModflowGhb_Writer.Extension) then
  begin
    FFeatureType := m6ftGhb;
  end
  else if SameText(FileExtension, TModflowRch_Writer.Extension) then
  begin
    FFeatureType := m6ftRch;
  end
  else if SameText(FileExtension, TModflowETS_Writer.Extension) then
  begin
    FFeatureType := m6ftEvt;
  end
  else if SameText(FileExtension, TCSubWriter.Extension) then
  begin
    FFeatureType := m6ftCSub;
  end
  else if SameText(FileExtension, TModflowMAW_Writer.Extension) then
  begin
    FFeatureType := m6ftMaw;
  end
  else if SameText(FileExtension, TModflowSFR_MF6_Writer.Extension) then
  begin
    FFeatureType := m6ftSfr;
  end
  else if SameText(FileExtension, TModflowLAKMf6Writer.Extension) then
  begin
    FFeatureType := m6ftLak;
  end
  else if SameText(FileExtension, TModflowUzfMf6Writer.Extension) then
  begin
    FFeatureType := m6ftUzf;
  end
  else
  begin
    Assert(False);
  end;
end;

function TModflow6FileReader.ReadAChdFeature(
  const Splitter: TStringList): TChdFeature;
var
  Value: string;
begin
  case FGridType of
    m6gtStructured:
      begin
        Assert(Splitter .Count >= 4);
      end;
    mggrDisv:
      begin
        Assert(Splitter .Count >= 3);
      end;
    else
      Assert(False);
  end;
  result := TChdFeature.Create;
  ReadCell(Splitter, result);

  case FGridType of
    m6gtStructured:
      begin
        Value := Splitter[3];
      end;
    mggrDisv:
      begin
        Value := Splitter[2];
      end;
    else
      Assert(False);
  end;
  result.FHead := ReadFromTimeSeriesOrConvert(Value);
end;

function TModflow6FileReader.ReadACSubFeature(
  const Splitter: TStringList): TCSubFeature;
begin
  case FGridType of
    m6gtStructured:
      begin
        Assert(Splitter .Count >= 4);
      end;
    mggrDisv:
      begin
        Assert(Splitter .Count >= 3);
      end;
    else
      Assert(False);
  end;
  result := TCSubFeature.Create;
  ReadCell(Splitter, result);
  case FGridType of
    m6gtStructured:
      begin
        result.FSig0 := ReadFromTimeSeriesOrConvert(Splitter[3]);
      end;
    mggrDisv:
      begin
        result.FSig0 := ReadFromTimeSeriesOrConvert(Splitter[2]);
      end;
    else
      Assert(False);
  end;
end;

function TModflow6FileReader.ReadADrnFeature(
  const Splitter: TStringList): TDrnFeature;
begin
  case FGridType of
    m6gtStructured:
      begin
        Assert(Splitter .Count >= 5);
      end;
    mggrDisv:
      begin
        Assert(Splitter .Count >= 4);
      end;
    else
      Assert(False);
  end;
  result := TDrnFeature.Create;
  ReadCell(Splitter, result);
  case FGridType of
    m6gtStructured:
      begin
        result.FElev := ReadFromTimeSeriesOrConvert(Splitter[3]);
        result.FCond := ReadFromTimeSeriesOrConvert(Splitter[4]);
      end;
    mggrDisv:
      begin
        result.FElev := ReadFromTimeSeriesOrConvert(Splitter[2]);
        result.FCond := ReadFromTimeSeriesOrConvert(Splitter[3]);
      end;
    else
      Assert(False);
  end;
end;

function TModflow6FileReader.ReadAEvtFeature(
  const Splitter: TStringList): TEvtFeature;
begin
  case FGridType of
    m6gtStructured:
      begin
        Assert(Splitter .Count >= 6);
      end;
    mggrDisv:
      begin
        Assert(Splitter .Count >= 5);
      end;
    else
      Assert(False);
  end;
  result := TEvtFeature.Create;
  ReadCell(Splitter, result);
  case FGridType of
    m6gtStructured:
      begin
        result.FSurface := ReadFromTimeSeriesOrConvert(Splitter[3]);
        result.FRate := ReadFromTimeSeriesOrConvert(Splitter[4]);
        result.FDepth := ReadFromTimeSeriesOrConvert(Splitter[5]);
      end;
    mggrDisv:
      begin
        result.FSurface := ReadFromTimeSeriesOrConvert(Splitter[2]);
        result.FRate := ReadFromTimeSeriesOrConvert(Splitter[3]);
        result.FDepth := ReadFromTimeSeriesOrConvert(Splitter[4]);
      end;
    else
      Assert(False);
  end;
end;

function TModflow6FileReader.ReadAFeature(
  const Splitter: TStringList): TModflow6Feature;
begin
  result := nil;
  case FFeatureType of
    m6ftWell: result := ReadAWellFeature(Splitter);
    m6ftChd: result := ReadAChdFeature(Splitter);
    m6ftDrn: result := ReadADrnFeature(Splitter);
    m6ftRiv: result := ReadARivFeature(Splitter);
    m6ftGhb: result := ReadAGhbFeature(Splitter);
    m6ftRch: result := ReadARchFeature(Splitter);
    m6ftEvt: result := ReadAEvtFeature(Splitter);
    m6ftCSub: result := ReadACSubFeature(Splitter);
    m6ftMaw: result := ReadAMawFeature(Splitter);
    m6ftSfr: result := ReadASfrFeature(Splitter);
    m6ftLak: result := ReadALakFeature(Splitter);
    m6ftUzf: result := ReadAUzfFeature(Splitter);
    else
      Assert(False);
  end;
end;

function TModflow6FileReader.ReadAGhbFeature(
  const Splitter: TStringList): TGhbFeature;
begin
  case FGridType of
    m6gtStructured:
      begin
        Assert(Splitter .Count >= 5);
      end;
    mggrDisv:
      begin
        Assert(Splitter .Count >= 4);
      end;
    else
      Assert(False);
  end;
  result := TGhbFeature.Create;
  ReadCell(Splitter, result);
  case FGridType of
    m6gtStructured:
      begin
        result.FHead := ReadFromTimeSeriesOrConvert(Splitter[3]);
        result.FCond := ReadFromTimeSeriesOrConvert(Splitter[4]);
      end;
    mggrDisv:
      begin
        result.FHead := ReadFromTimeSeriesOrConvert(Splitter[2]);
        result.FCond := ReadFromTimeSeriesOrConvert(Splitter[3]);
      end;
    else
      Assert(False);
  end;
end;

function TModflow6FileReader.ReadALakFeature(
  const Splitter: TStringList): TSfrFeature;
var
  LakeNo: Integer;
  KeyWord: string;
  Status: string;
begin
  result := nil;
  Assert(Splitter.Count >= 3);
  LakeNo := StrToInt(Splitter[0]);
  Assert(LakeNo >0);
  Assert(LakeNo <= FNumberOfLakes);
  KeyWord := UpperCase(Splitter[1]);
  if KeyWord = 'STATUS' then
  begin
    Status := UpperCase(Splitter[2]);
    if Status = 'ACTIVE' then
    begin
      FLakeProperties[LakeNo-1].FStatus := lsActive;
    end
    else if Status = 'INACTIVE' then
    begin
      FLakeProperties[LakeNo-1].FStatus := lsInactive;
    end
    else if Status = 'CONSTANT' then
    begin
      FLakeProperties[LakeNo-1].FStatus := lsConstant;
    end
    else
    begin
      Assert(False);
    end;
  end
  else if KeyWord = 'STAGE' then
  begin
    FLakeProperties[LakeNo-1].FSTAGE := ReadFromTimeSeriesOrConvert(Splitter[2]);
  end
  else if KeyWord = 'RAINFALL' then
  begin
    FLakeProperties[LakeNo-1].FRAINFALL := ReadFromTimeSeriesOrConvert(Splitter[2]);
  end
  else if KeyWord = 'EVAPORATION' then
  begin
    FLakeProperties[LakeNo-1].FEVAPORATION := ReadFromTimeSeriesOrConvert(Splitter[2]);
  end
  else if KeyWord = 'RUNOFF' then
  begin
    FLakeProperties[LakeNo-1].FRUNOFF := ReadFromTimeSeriesOrConvert(Splitter[2]);
  end
  else if KeyWord = 'INFLOW' then
  begin
    FLakeProperties[LakeNo-1].FINFLOW := ReadFromTimeSeriesOrConvert(Splitter[2]);
  end
  else if KeyWord = 'WITHDRAWAL' then
  begin
    FLakeProperties[LakeNo-1].FWITHDRAWAL := ReadFromTimeSeriesOrConvert(Splitter[2]);
  end
end;

function TModflow6FileReader.ReadAMawFeature(
  const Splitter: TStringList): TMawFeature;
var
  WellNo: Integer;
  KeyWord: string;
  Status: string;
begin
  result := nil;
  Assert(Splitter.Count >= 3);
  WellNo := StrToInt(Splitter[0]);
  Assert(WellNo >0);
  Assert(WellNo <= FNumberOfMawWells);
  KeyWord := UpperCase(Splitter[1]);
  if KeyWord = 'STATUS' then
  begin
    Status := UpperCase(Splitter[2]);
    if Status = 'ACTIVE' then
    begin
      FMawWellProperties[WellNo-1].FStatus := mwActive;
    end
    else if Status = 'INACTIVE' then
    begin
      FMawWellProperties[WellNo-1].FStatus := mwInactive;
    end
    else if Status = 'CONSTANT' then
    begin
      FMawWellProperties[WellNo-1].FStatus := mwConstantHead;
    end
    else
    begin
      Assert(False);
    end;
  end
  else if KeyWord = 'FLOWING_WELL' then
  begin
    FMawWellProperties[WellNo-1].FFlowingWell := True;
    FMawWellProperties[WellNo-1].FFwelev := FortranStrToFloat(Splitter[2]);
    FMawWellProperties[WellNo-1].FFwcond := FortranStrToFloat(Splitter[3]);
    FMawWellProperties[WellNo-1].FFwrlen := FortranStrToFloat(Splitter[4]);
  end
  else if KeyWord = 'RATE' then
  begin
    FMawWellProperties[WellNo-1].FRate := ReadFromTimeSeriesOrConvert(Splitter[2]);
  end
  else if KeyWord = 'WELL_HEAD' then
  begin
    FMawWellProperties[WellNo-1].FWell_Head := ReadFromTimeSeriesOrConvert(Splitter[2]);
  end
  else if KeyWord = 'HEAD_LIMIT' then
  begin
    FMawWellProperties[WellNo-1].FHeadLimitUsed := True;
    FMawWellProperties[WellNo-1].FHead_limit := FortranStrToFloat(Splitter[2]);
  end
  else if KeyWord = 'SHUT_OFF' then
  begin
    FMawWellProperties[WellNo-1].FShutOff := True;
    FMawWellProperties[WellNo-1].FMinRate := FortranStrToFloat(Splitter[2]);
    FMawWellProperties[WellNo-1].FMaxRate := FortranStrToFloat(Splitter[3]);
  end
  else if KeyWord = 'RATE_SCALING' then
  begin
    FMawWellProperties[WellNo-1].FRateScaling := True;
    FMawWellProperties[WellNo-1].FPumpElevation := FortranStrToFloat(Splitter[2]);
    FMawWellProperties[WellNo-1].FScalingLength := FortranStrToFloat(Splitter[3]);
  end

end;

function TModflow6FileReader.ReadARchFeature(
  const Splitter: TStringList): TRchFeature;
begin
  case FGridType of
    m6gtStructured:
      begin
        Assert(Splitter .Count >= 4);
      end;
    mggrDisv:
      begin
        Assert(Splitter .Count >= 3);
      end;
    else
      Assert(False);
  end;
  result := TRchFeature.Create;
  ReadCell(Splitter, result);
  case FGridType of
    m6gtStructured:
      begin
        result.FRecharge := ReadFromTimeSeriesOrConvert(Splitter[3]);
      end;
    mggrDisv:
      begin
        result.FRecharge := ReadFromTimeSeriesOrConvert(Splitter[2]);
      end;
    else
      Assert(False);
  end;
end;

function TModflow6FileReader.ReadARivFeature(
  const Splitter: TStringList): TRivFeature;
begin
  case FGridType of
    m6gtStructured:
      begin
        Assert(Splitter .Count >= 6);
      end;
    mggrDisv:
      begin
        Assert(Splitter .Count >= 5);
      end;
    else
      Assert(False);
  end;
  result := TRivFeature.Create;
  ReadCell(Splitter, result);
  case FGridType of
    m6gtStructured:
      begin
        result.FStage := ReadFromTimeSeriesOrConvert(Splitter[3]);
        result.FCond := ReadFromTimeSeriesOrConvert(Splitter[4]);
        result.FRBot := ReadFromTimeSeriesOrConvert(Splitter[5]);
      end;
    mggrDisv:
      begin
        result.FStage := ReadFromTimeSeriesOrConvert(Splitter[2]);
        result.FCond := ReadFromTimeSeriesOrConvert(Splitter[3]);
        result.FRBot := ReadFromTimeSeriesOrConvert(Splitter[4]);
      end;
    else
      Assert(False);
  end;
end;

function TModflow6FileReader.ReadASfrFeature(
  const Splitter: TStringList): TSfrFeature;
var
  ReachNo: Integer;
  AReach: TSfrFeature;
  KeyWord: string;
  Status: string;
begin
  result := nil;
  Assert(Splitter.Count >= 3);
  ReachNo := StrToInt(Splitter[0]);
  AReach := FSfrFeatures[ReachNo-1];
  KeyWord := UpperCase(Splitter[1]);
  if KeyWord = 'STATUS' then
  begin
    Status := Splitter[2];
    if SameText(Status, 'ACTIVE') then
    begin
      AReach.FStatus := ssActive;
    end
    else if SameText(Status, 'INACTIVE') then
    begin
      AReach.FStatus := ssInactive;
    end
    else if SameText(Status, 'ssSimple') then
    begin
      AReach.FStatus := ssSimple;
    end;
  end
  else if KeyWord = 'MANNING' then
  begin
    AReach.FManning := ReadFromTimeSeriesOrConvert(Splitter[2]);
  end
  else if KeyWord = 'STAGE' then
  begin
    AReach.FSTAGE := ReadFromTimeSeriesOrConvert(Splitter[2]);
  end
  else if KeyWord = 'INFLOW' then
  begin
    AReach.FINFLOW := ReadFromTimeSeriesOrConvert(Splitter[2]);
  end
  else if KeyWord = 'RAINFALL' then
  begin
    AReach.FRAINFALL := ReadFromTimeSeriesOrConvert(Splitter[2]);
  end
  else if KeyWord = 'EVAPORATION' then
  begin
    AReach.FEVAPORATION := ReadFromTimeSeriesOrConvert(Splitter[2]);
  end
  else if KeyWord = 'RUNOFF' then
  begin
    AReach.FRUNOFF := ReadFromTimeSeriesOrConvert(Splitter[2]);
  end
  else if KeyWord = 'UPSTREAM_FRACTION' then
  begin
    AReach.FUPSTREAM_FRACTION := StrToFloat(Splitter[2]);
  end;
end;

function TModflow6FileReader.ReadAUzfFeature(
  const Splitter: TStringList): TUzfFeature;
var
  UzfNo: Integer;
begin
  Assert(Splitter .Count >= 8);
  result := TUzfFeature.Create;
  UzfNo := StrToInt(Splitter[0]);
  result.Cell := FUzfCells[UzfNo-1];
  result.FFinf := ReadFromTimeSeriesOrConvert(Splitter[1]);
  result.FPet := ReadFromTimeSeriesOrConvert(Splitter[2]);
  result.FExtdp := ReadFromTimeSeriesOrConvert(Splitter[3]);
  result.FExtwc := ReadFromTimeSeriesOrConvert(Splitter[4]);
  result.FHa := ReadFromTimeSeriesOrConvert(Splitter[5]);
  result.FHRoot := ReadFromTimeSeriesOrConvert(Splitter[6]);
  result.FRootAct := ReadFromTimeSeriesOrConvert(Splitter[7]);
end;

function TModflow6FileReader.ReadAWellFeature(
  const Splitter: TStringList): TWellFeature;
begin
  case FGridType of
    m6gtStructured:
      begin
        Assert(Splitter .Count >= 4);
      end;
    mggrDisv:
      begin
        Assert(Splitter .Count >= 3);
      end;
    else
      Assert(False);
  end;
  result := TWellFeature.Create;
  ReadCell(Splitter, result);
  case FGridType of
    m6gtStructured:
      begin
        result.FQ := ReadFromTimeSeriesOrConvert(Splitter[3]);
      end;
    mggrDisv:
      begin
        result.FQ := ReadFromTimeSeriesOrConvert(Splitter[2]);
      end;
    else
      Assert(False);
  end;
end;

procedure TModflow6FileReader.ReadCell(Splitter: TStringList;
  AFeature: TModflow6Feature);
begin
  case FGridType of
    m6gtStructured:
      begin
        AFeature.FCell.Layer := StrToInt(Splitter[0]);
        AFeature.FCell.Row := StrToInt(Splitter[1]);
        AFeature.FCell.Column := StrToInt(Splitter[2]);
      end;
    mggrDisv:
      begin
        Assert(Splitter .Count >= 3);
        AFeature.FCell.Layer := StrToInt(Splitter[0]);
        AFeature.FCell.Row := 1;
        AFeature.FCell.Column := StrToInt(Splitter[1]);
      end;
    else
      Assert(False);
  end;

end;

function TModflow6FileReader.ReadFromTimeSeriesOrConvert(Text: string): double;
var
  TimeCollection: TTimesSeriesCollection;
  LocalModel: TPhastModel;
  ATime: Double;
  ASeries: TMf6TimeSeries;
begin
  TimeCollection := FTimeSeries.GetTimesSeriesCollectionBySeriesName(Text);
  if TimeCollection = nil then
  begin
    result := FortranStrToFloat(Text);
  end
  else
  begin
    LocalModel := frmGoPhast.PhastModel;
    ASeries := TimeCollection.GetValuesByName(Text);
    if ASeries.InterpolationMethod = mimStepwise then
    begin
      ATime := LocalModel.ModflowStressPeriods[FStressPeriod-1].StartTime;
    end
    else
    begin
      ATime := LocalModel.ModflowStressPeriods[FStressPeriod-1].EndTime;
    end;

    result := TimeCollection.GetInterpolatedValue(LocalModel, ATime, Text,
      LocalModel.ModflowStressPeriods.First.StartTime);
  end;
end;

procedure TModflow6FileReader.ReadLakCells;
var
  Count: Integer;
  ALine: string;
  Splitter: TStringList;
  ACell: TCellLocation;
  LakeNo: Integer;
  ICon: Integer;
begin
  Splitter := TStringList.Create;
  try
    Count := 0;
    while (Count < FNumberOfLakeCells) and (not FInputFile.EndOfStream) do
    begin
      ALine := ExtractNonCommentLine(FInputFile.ReadLine);
      if ALine = '' then
      begin
        Continue;
      end;
      Splitter.DelimitedText := ALine;
      case FGridType of
        m6gtStructured:
          begin
            Assert(Splitter.Count >= 5);
          end;
        mggrDisv:
          begin
            Assert(Splitter.Count >= 4);
          end;
        else
          Assert(False);
      end;
      LakeNo := StrToInt(Splitter[0]);
      Assert(LakeNo > 0);
      Assert(LakeNo <= FNumberOfLakes);
      ICon := StrToInt(Splitter[1]);
      Assert(ICon > 0);
      Assert(Icon <= Length(FLakeCells[LakeNo-1]));
      case FGridType of
        m6gtStructured:
          begin
            ACell.Layer := StrToInt(Splitter[2]);
            ACell.Row := StrToInt(Splitter[3]);
            ACell.Column := StrToInt(Splitter[4]);
          end;
        mggrDisv:
          begin
            ACell.Layer := StrToInt(Splitter[2]);
            ACell.Row := 1;
            ACell.Column := StrToInt(Splitter[3]);
          end;
        else
          Assert(False);
      end;
      FLakeCells[LakeNo-1, ICon-1] := ACell;
      Inc(Count);
    end;
  finally
    Splitter.Free;
  end;
end;

procedure TModflow6FileReader.ReadMawWellCells;
var
  Count: Integer;
  ALine: string;
  Splitter: TStringList;
  ACell: TCellLocation;
  WellNo: Integer;
  ICon: Integer;
begin
  Splitter := TStringList.Create;
  try
    Count := 0;
    while (Count < FNumberOfMawCells) and (not FInputFile.EndOfStream) do
    begin
      ALine := ExtractNonCommentLine(FInputFile.ReadLine);
      if ALine = '' then
      begin
        Continue;
      end;
      Splitter.DelimitedText := ALine;
      case FGridType of
        m6gtStructured:
          begin
            Assert(Splitter.Count >= 5);
          end;
        mggrDisv:
          begin
            Assert(Splitter.Count >= 4);
          end;
        else
          Assert(False);
      end;
      WellNo := StrToInt(Splitter[0]);
      Assert(WellNo > 0);
      Assert(WellNo <= FNumberOfMawWells);
      ICon := StrToInt(Splitter[1]);
      Assert(ICon > 0);
      Assert(Icon <= Length(FMawWellCells[WellNo-1]));
      case FGridType of
        m6gtStructured:
          begin
            ACell.Layer := StrToInt(Splitter[2]);
            ACell.Row := StrToInt(Splitter[3]);
            ACell.Column := StrToInt(Splitter[4]);
          end;
        mggrDisv:
          begin
            ACell.Layer := StrToInt(Splitter[2]);
            ACell.Row := 1;
            ACell.Column := StrToInt(Splitter[3]);
          end;
        else
          Assert(False);
      end;
      FMawWellCells[WellNo-1, ICon-1] := ACell;
      Inc(Count);
    end;
  finally
    Splitter.Free;
  end;
end;

procedure TModflow6FileReader.ReadMawWellCellsPerWell;
var
  WellNo: Integer;
  Ngwfnodes: Integer;
  Splitter: TStringList;
  ALine: string;
  Count: Integer;
begin
  FNumberOfMawCells := 0;
  Count := 0;
  Splitter := TStringList.Create;
  try
    while (Count < FNumberOfMawWells) and not FInputFile.EndOfStream do
    begin
      ALine := ExtractNonCommentLine(FInputFile.ReadLine);
      if ALine = '' then
      begin
        Continue;
      end;
      Splitter.DelimitedText := ALine;
      Assert(Splitter.Count >= 6);
      WellNo := StrToInt(Splitter[0]);
      Assert(WellNo > 0);
      Assert(WellNo <= FNumberOfMawWells);
      Ngwfnodes := StrToInt(Splitter[5]);
      Inc(FNumberOfMawCells, Ngwfnodes);
      SetLength(FMawWellCells[WellNo-1], Ngwfnodes);
      Inc(Count);

      Assert(not IsEndOfSection(ALine));
    end;
  finally
    Splitter.Free;
  end;
end;

procedure TModflow6FileReader.ReadNumberOfCellsPerLake;
var
  LakeNo: Integer;
  Splitter: TStringList;
  ALine: string;
  Count: Integer;
  nlakeconn: Integer;
begin
  FNumberOfLakeCells := 0;
  Count := 0;
  Splitter := TStringList.Create;
  try
    while (Count < FNumberOfLakes) and not FInputFile.EndOfStream do
    begin
      ALine := ExtractNonCommentLine(FInputFile.ReadLine);
      if ALine = '' then
      begin
        Continue;
      end;
      Splitter.DelimitedText := ALine;
      Assert(Splitter.Count >= 3);
      LakeNo := StrToInt(Splitter[0]);
      Assert(LakeNo > 0);
      Assert(LakeNo <= FNumberOfLakes);
      nlakeconn := StrToInt(Splitter[2]);
      Inc(FNumberOfLakeCells, nlakeconn);
      SetLength(FLakeCells[LakeNo-1], nlakeconn);
      Inc(Count);

      Assert(not IsEndOfSection(ALine));
    end;
  finally
    Splitter.Free;
  end;
end;

procedure TModflow6FileReader.ReadNumberOfLakes;
begin
  FNumberOfLakes := GetNumberOfItems('NLAKES');
  SetLength(FLakeCells, FNumberOfLakes);
  SetLength(FLakeProperties, FNumberOfLakes);
  InitializeLakeProperties;
end;

procedure TModflow6FileReader.ReadNumberOfMawWells;
begin
  FNumberOfMawWells := GetNumberOfItems('NMAWWELLS');
  SetLength(FMawWellCells, FNumberOfMawWells);
  SetLength(FMawWellProperties, FNumberOfMawWells);
  InitializeMawWellProperties;
end;

procedure TModflow6FileReader.ReadNumberOfSfrCells;
var
  Index: Integer;
begin
  FNumberOfReaches := GetNumberOfItems('NREACHES');
  FSfrFeatures.Capacity := FNumberOfReaches;
  for Index := 0 to FNumberOfReaches - 1 do
  begin
    FSfrFeatures.Add(TSfrFeature.Create);
  end;
end;

procedure TModflow6FileReader.ReadNumberOfUzfCells;
begin
  FNumberUzfCells := GetNumberOfItems('NUZFCELLS');
  SetLength(FUzfCells, FNumberUzfCells);
end;

procedure TModflow6FileReader.ReadSfrCells;
var
  Splitter: TStringList;
  Count: Integer;
  ALine: string;
  ReachNo: Integer;
  ACell: TCellLocation;
begin
  Splitter := TStringList.Create;
  try
    Count := 0;
    while (Count < FNumberOfReaches) and (not FInputFile.EndOfStream) do
    begin
      ALine := ExtractNonCommentLine(FInputFile.ReadLine);
      if ALine = '' then
      begin
        Continue;
      end;
      Splitter.DelimitedText := ALine;
      case FGridType of
        m6gtStructured:
          begin
            Assert(Splitter.Count >= 4);
          end;
        mggrDisv:
          begin
            Assert(Splitter.Count >= 3);
          end;
        else
          Assert(False);
      end;
      ReachNo := StrToInt(Splitter[0]);
      Assert(ReachNo > 0);
      Assert(ReachNo <= FNumberOfReaches);
      case FGridType of
        m6gtStructured:
          begin
            ACell.Layer := StrToInt(Splitter[1]);
            ACell.Row := StrToInt(Splitter[2]);
            ACell.Column := StrToInt(Splitter[3]);
          end;
        mggrDisv:
          begin
            ACell.Layer := StrToInt(Splitter[1]);
            ACell.Row := 1;
            ACell.Column := StrToInt(Splitter[2]);
          end;
        else
          Assert(False);
      end;
      FSfrFeatures[ReachNo-1].FCell := ACell;
      Inc(Count);
    end;
  finally
    Splitter.Free;
  end;
end;

procedure TModflow6FileReader.ReadOptions;
const
  FILEIN = 'FILEIN';
var
  ALine: string;
  FileNameStart: Integer;
  TsFileName: string;
begin
  while not FInputFile.EndOfStream do
  begin
    ALine := ExtractNonCommentLine(FInputFile.ReadLine);
    if IsEndOfSection(ALine) then
    begin
      break;
    end;
    if Pos('TS6', ALine) = 1 then
    begin
      FileNameStart := Pos(FILEIN, ALine) + Length(FILEIN);
      TsFileName := Trim(Copy(ALine, FileNameStart, MAXINT));
      ReadTimeSeriesFile(TsFileName);
    end;
  end;

end;

function TModflow6FileReader.ReadStressPeriod(
  StressPeriod: Integer): TModflowFeatureList;
var
  ALine: string;
  Section: string;
  CurrentPeriod: Integer;
  Splitter: TStringList;
  PeriodPosition: Integer;
  procedure SkipToEndOfSection;
  begin
    while not FInputFile.EndOfStream do
    begin
      ALine := ExtractNonCommentLine(FInputFile.ReadLine);
      if IsEndOfSection(ALine) then
      begin
        break;
      end;
    end;
  end;
begin
  FStressPeriod := StressPeriod;
  Splitter := TStringList.Create;
  try
    result := TModflowFeatureList.Create;
    while not FInputFile.EndOfStream do
    begin
      ALine := ExtractNonCommentLine(FInputFile.ReadLine);
      if ALine = '' then
      begin
        Continue;
      end;
      if IsBeginningOfSection(ALine, Section) then
      begin
        if SameText(Section, 'OPTIONS') then
        begin
          ReadOptions;
        end
        else if SameText(Section, 'DIMENSIONS') then
        begin
          if FFeatureType = m6ftMAW then
          begin
            ReadNumberOfMawWells;
          end
          else if FFeatureType = m6ftSfr then
          begin
            ReadNumberOfSfrCells;
          end
          else if FFeatureType = m6ftLak then
          begin
            ReadNumberOfLakes;
          end
          else if FFeatureType = m6ftUzf then
          begin
            ReadNumberOfUzfCells;
          end;
          SkipToEndOfSection;
        end
        else if SameText(Section, 'GRIDDATA') then
        begin
          SkipToEndOfSection;
        end
        else if SameText(Section, 'PACKAGEDATA') then
        begin
          if FFeatureType = m6ftMAW then
          begin
            ReadMawWellCellsPerWell;
          end
          else if FFeatureType = m6ftSfr then
          begin
            ReadSfrCells;
          end
          else if FFeatureType = m6ftLak then
          begin
            ReadNumberOfCellsPerLake;
          end
          else if FFeatureType = m6ftUzf then
          begin
            ReadUzfCells
          end;
          SkipToEndOfSection;
        end
        else if SameText(Section, 'CONNECTIONDATA') then
        begin
          if FFeatureType = m6ftMAW then
          begin
            ReadMawWellCells;
          end
          else if FFeatureType = m6ftLak then
          begin
            ReadLakCells;
          end;
          SkipToEndOfSection;
        end
        else if SameText(Section, 'TABLES') then
        begin
          SkipToEndOfSection;
        end
        else if SameText(Section, 'OUTLETS') then
        begin
          SkipToEndOfSection;
        end
        else
        begin
          PeriodPosition := Pos('PERIOD ', UpperCase(Section));
          if PeriodPosition = 1 then
          begin
            CurrentPeriod := StrToInt(Trim(Copy(Section, Length('PERIOD ')+1,
              MAXINT)));
            if CurrentPeriod > StressPeriod then
            begin
              Exit;
            end;
            result.Clear;

            while not FInputFile.EndOfStream do
            begin
              ALine := ExtractNonCommentLine(FInputFile.ReadLine);
              if ALine = '' then
              begin
                Continue;
              end;
              if IsEndOfSection(ALine) then
              begin
                break;
              end;
              Splitter.DelimitedText := ALine;
              result.Add(ReadAFeature(Splitter));
            end;
          end
          else
          begin
            Assert(False);
          end;
        end;
      end;
    end;
    if FFeatureType = m6ftMAW then
    begin
      FinalizeMawFeatures(result);
    end
    else if FFeatureType = m6ftSfr then
    begin
      FinalizeSfrFeatures(result);
    end
    else if FFeatureType = m6ftLak then
    begin
      FinalizeLakeFeatures(result);
    end;
  finally
    Splitter.Free;
  end;

end;

procedure TModflow6FileReader.ReadTimeSeriesFile(const TsFileName: string);
var
  ATimeSeries: TTimesSeriesCollection;
begin
  ATimeSeries := FTimeSeries.Add.TimesSeriesCollection;
  ATimeSeries.ReadFromFile(TsFileName)
end;

procedure TModflow6FileReader.ReadUzfCells;
var
  Count: Integer;
  ALine: string;
  Splitter: TStringList;
  ACell: TCellLocation;
  UzfNo: Integer;
begin
  Splitter := TStringList.Create;
  try
    Count := 0;
    while (Count < FNumberUzfCells) and (not FInputFile.EndOfStream) do
    begin
      ALine := ExtractNonCommentLine(FInputFile.ReadLine);
      if ALine = '' then
      begin
        Continue;
      end;
      Splitter.DelimitedText := ALine;
      case FGridType of
        m6gtStructured:
          begin
            Assert(Splitter.Count >= 4);
          end;
        mggrDisv:
          begin
            Assert(Splitter.Count >= 4);
          end;
        else
          Assert(False);
      end;
      UzfNo := StrToInt(Splitter[0]);
      Assert(UzfNo > 0);
      Assert(UzfNo <= FNumberUzfCells);
      case FGridType of
        m6gtStructured:
          begin
            ACell.Layer := StrToInt(Splitter[1]);
            ACell.Row := StrToInt(Splitter[2]);
            ACell.Column := StrToInt(Splitter[3]);
          end;
        mggrDisv:
          begin
            ACell.Layer := StrToInt(Splitter[1]);
            ACell.Row := 1;
            ACell.Column := StrToInt(Splitter[2]);
          end;
        else
          Assert(False);
      end;
      FUzfCells[UzfNo-1] := ACell;
      Inc(Count);
    end;
  finally
    Splitter.Free;
  end;
end;

{ TMawRecord }

procedure TMawRecord.Initialize;
begin
  FStatus := mwActive;
  FFlowingWell := False;
  FRate := 0;
  FHeadLimitUsed := False;
  FShutOff := False;
  FRateScaling := False;
end;

{ TSfrFeature }

constructor TSfrFeature.Create;
begin
  FStatus := ssActive;
end;

{ TLakeRecord }

procedure TLakeRecord.Initialize;
begin
  FStatus := lsActive;
  FRAINFALL := 0;
  FEVAPORATION := 0;
  FRUNOFF := 0;
  FINFLOW := 0;
  FWITHDRAWAL := 0;
end;

end.
