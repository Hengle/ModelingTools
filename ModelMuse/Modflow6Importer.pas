{ @name is used to read a model feature input file generated by PEST for
  display in ModelMuse.
}
unit Modflow6Importer;

interface

uses
  System.Classes, System.SysUtils, System.IOUtils, ModflowCellUnit,
  System.Generics.Collections;

type
  TModflow6Feature = class(TObject)
  private
    FCell: TCellLocation;
  public
    property Cell: TCellLocation read FCell write FCell;
  end;

  TModflowFeatureList = TObjectList<TModflow6Feature>;

  TChdFeature = class(TModflow6Feature)
  private
    FHead: double;
  public
    property Head: double read FHead;
  end;

  TWellFeature = class(TModflow6Feature)
  private
    FQ: double;
  public
    property Q: double read FQ;
  end;

  TModflow6FeatureType = (m6ftChd, m6ftWell);
  TModflow6GridType = (m6gtStructured, mggrDisv);

  TModflow6FileReader = class (TObject)
  private
    FFeatureType: TModflow6FeatureType;
    FInputFile: TStreamReader;
    FGridType: TModflow6GridType;
    {
    @name removes comments from a line and converts it to upper case.
    If the entire line is a comment, @name returns an empty string.
    }
    function ExtractNonCommentLine(const ALine: string): string;
    {@name checks a line that has been proccessed by
    @link(ExtractNonCommentLine) and returns @True if it marks the beginning
    of a section. If it does mark the beginning of a section, Section identifies
    the section.}
    function IsBeginningOfSection(const ALine: string;
      out Section: string): Boolean;
    function IsEndOfSection(const ALine: string): Boolean;
    function ReadAFeature(const Splitter: TStringList): TModflow6Feature;
    function ReadAWellFeature(const Splitter: TStringList): TWellFeature;
    function ReadAChdFeature(const Splitter: TStringList): TChdFeature;
    procedure ReadCell(Splitter: TStringList; AFeature: TModflow6Feature);
  public
    constructor Create(GridType: TModflow6GridType);
    procedure OpenFile(const FileName: string);
    function ReadStressPeriod(StressPeriod: Integer): TModflowFeatureList;
    destructor Destroy; override;
    property FeatureType: TModflow6FeatureType read FFeatureType;
  end;

implementation

uses
  ModflowWellWriterUnit, ModelMuseUtilities, ModflowCHD_WriterUnit;

{ TModflow6FileReader }

constructor TModflow6FileReader.Create(GridType: TModflow6GridType);
begin
  inherited Create;
  FGridType := GridType;
end;

destructor TModflow6FileReader.Destroy;
begin
  FInputFile.Free;
  inherited;
end;

function TModflow6FileReader.ExtractNonCommentLine(const ALine: string): string;
var
  CommentMarkerPosition: Integer;
begin
  result := Trim(ALine);

  if (Pos('#', result) = 1) or (Pos('!', result) = 1)  or (Pos('//', result) = 1) then
  begin
    result := '';
    Exit;
  end;
  CommentMarkerPosition := Pos('#', result);
  if CommentMarkerPosition > 1 then
  begin
    result := Copy(result, 1, CommentMarkerPosition-1);
  end;
  CommentMarkerPosition := Pos('!', result);
  if CommentMarkerPosition > 1 then
  begin
    result := Copy(result, 1, CommentMarkerPosition-1);
  end;
  CommentMarkerPosition := Pos('//', result);
  if CommentMarkerPosition > 1 then
  begin
    result := Copy(result, 1, CommentMarkerPosition-1);
  end;
  result := UpperCase(result);
end;

function TModflow6FileReader.IsBeginningOfSection(const ALine: string;
  out Section: string): Boolean;
const
  strBegin = 'BEGIN ';
var
  BeginPosition: Integer;
begin
  BeginPosition := Pos(strBegin, ALine);
  result := BeginPosition = 1;
  if result then
  begin
    Section := Copy(ALine, Length(strBegin)+1, MAXINT);
  end
  else
  begin
    Section := '';
  end;
end;

function TModflow6FileReader.IsEndOfSection(const ALine: string): Boolean;
begin
  result := Pos('END', ALine) = 1;
end;

procedure TModflow6FileReader.OpenFile(const FileName: string);
var
  FileExtension: string;
begin
  FInputFile := TFile.OpenText(FileName);
  FileExtension := LowerCase(ExtractFileExt(FileName));
  if FileExtension = TModflowCHD_Writer.Extension then
  begin
    FFeatureType := m6ftChd;
  end
  else if FileExtension = TModflowWEL_Writer.Extension then
  begin
    FFeatureType := m6ftWell;
  end
  else
  begin
    Assert(False);
  end;

end;

function TModflow6FileReader.ReadAChdFeature(
  const Splitter: TStringList): TChdFeature;
begin
  case FGridType of
    m6gtStructured:
      begin
        Assert(Splitter .Count >= 4);
      end;
    mggrDisv:
      begin
        Assert(Splitter .Count >= 3);
      end;
    else
      Assert(False);
  end;
  result := TChdFeature.Create;
  ReadCell(Splitter, result);
  case FGridType of
    m6gtStructured:
      begin
        result.FHead := FortranStrToFloat(Splitter[3]);
      end;
    mggrDisv:
      begin
        result.FHead := FortranStrToFloat(Splitter[2]);
      end;
    else
      Assert(False);
  end;
end;

function TModflow6FileReader.ReadAFeature(
  const Splitter: TStringList): TModflow6Feature;
begin
  result := nil;
  case FFeatureType of
    m6ftWell: result := ReadAWellFeature(Splitter);
    m6ftChd: result := ReadAChdFeature(Splitter);
    else
      Assert(False);
  end;
end;

function TModflow6FileReader.ReadAWellFeature(
  const Splitter: TStringList): TWellFeature;
begin
  case FGridType of
    m6gtStructured:
      begin
        Assert(Splitter .Count >= 4);
      end;
    mggrDisv:
      begin
        Assert(Splitter .Count >= 3);
      end;
    else
      Assert(False);
  end;
  result := TWellFeature.Create;
  ReadCell(Splitter, result);
  case FGridType of
    m6gtStructured:
      begin
        result.FQ := FortranStrToFloat(Splitter[3]);
      end;
    mggrDisv:
      begin
        result.FQ := FortranStrToFloat(Splitter[2]);
      end;
    else
      Assert(False);
  end;
end;

procedure TModflow6FileReader.ReadCell(Splitter: TStringList;
  AFeature: TModflow6Feature);
begin
  case FGridType of
    m6gtStructured:
      begin
        AFeature.FCell.Layer := StrToInt(Splitter[0]);
        AFeature.FCell.Row := StrToInt(Splitter[1]);
        AFeature.FCell.Column := StrToInt(Splitter[2]);
      end;
    mggrDisv:
      begin
        Assert(Splitter .Count >= 3);
        AFeature.FCell.Layer := StrToInt(Splitter[0]);
        AFeature.FCell.Row := 1;
        AFeature.FCell.Column := StrToInt(Splitter[1]);
      end;
    else
      Assert(False);
  end;

end;

function TModflow6FileReader.ReadStressPeriod(
  StressPeriod: Integer): TModflowFeatureList;
var
  ALine: string;
  Section: string;
  CurrentPeriod: Integer;
  Splitter: TStringList;
  PeriodPosition: Integer;
begin
  Splitter := TStringList.Create;
  try
    result := TModflowFeatureList.Create;
    while not FInputFile.EndOfStream do
    begin
      ALine := ExtractNonCommentLine(FInputFile.ReadLine);
      if ALine = '' then
      begin
        Continue;
      end;
      if IsBeginningOfSection(ALine, Section) then
      begin
        if Section = 'OPTIONS' then
        begin
          while not FInputFile.EndOfStream do
          begin
            ALine := ExtractNonCommentLine(FInputFile.ReadLine);
            if IsEndOfSection(ALine) then
            begin
              break;
            end;
          end;
        end
        else if Section = 'DIMENSIONS' then
        begin
          while not FInputFile.EndOfStream do
          begin
            ALine := ExtractNonCommentLine(FInputFile.ReadLine);
            if IsEndOfSection(ALine) then
            begin
              break;
            end;
          end;
        end
        else
        begin
          PeriodPosition := Pos('PERIOD ', Section);
          if PeriodPosition = 1 then
          begin
            CurrentPeriod := StrToInt(Trim(Copy(Section, Length('PERIOD ')+1,
              MAXINT)));
            if CurrentPeriod > StressPeriod then
            begin
              Exit;
            end;
            result.Clear;
            while not FInputFile.EndOfStream do
            begin
              ALine := ExtractNonCommentLine(FInputFile.ReadLine);
              if ALine = '' then
              begin
                Continue;
              end;
              if IsEndOfSection(ALine) then
              begin
                break;
              end;
              Splitter.DelimitedText := ALine;
              result.Add(ReadAFeature(Splitter));
            end;
          end
          else
          begin
            Assert(False);
          end;
        end;
      end;
    end;
  finally
    Splitter.Free;
  end;

end;

end.
